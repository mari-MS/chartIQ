(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["addOns"],{

/***/ "./src/js/addOns.js":
/*!**************************!*\
  !*** ./src/js/addOns.js ***!
  \**************************/
/*! exports provided: animation, continuousZoom, extendedHours, fullScreen, inactivityTimer, outliers, plotComplementer, rangeSlider, tooltip, CIQ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animation\", function() { return __js_addons_animation_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"continuousZoom\", function() { return __js_addons_continuousZoom_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extendedHours\", function() { return __js_addons_extendedHours_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fullScreen\", function() { return __js_addons_fullScreen_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inactivityTimer\", function() { return __js_addons_inactivityTimer_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"outliers\", function() { return __js_addons_outliers_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plotComplementer\", function() { return __js_addons_plotComplementer_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rangeSlider\", function() { return __js_addons_rangeSlider_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tooltip\", function() { return __js_addons_tooltip_; });\n/* harmony import */ var _js_chartiq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../js/chartiq.js */ \"./src/js/chartiq.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CIQ\", function() { return _js_chartiq_js__WEBPACK_IMPORTED_MODULE_0__[\"CIQ\"]; });\n\n/**\n *\t8.0.0\n *\tGeneration date: 2020-10-06T16:02:04.903Z\n *\tClient name: unlocked\n *\tPackage Type: Technical Analysis\n *\tLicense type: annual\n *\tExpiration date: \"2021/07/13\"\n *\tDomain lock: [\"127.0.0.1\",\"localhost\",\"192.168.1.61\",\"chartiq.com\",\"fiddle.jshell.net\",\"jsfiddle.net\"]\n *\tiFrame lock: true\n */\n\n/***********************************************************\n * Copyright by ChartIQ, Inc.\n * Licensed under the ChartIQ, Inc. Developer License Agreement https://www.chartiq.com/developer-license-agreement\n*************************************************************/\n/*************************************** DO NOT MAKE CHANGES TO THIS LIBRARY FILE!! **************************************/\n/* If you wish to overwrite default functionality, create a separate file with a copy of the methods you are overwriting */\n/* and load that file right after the library has been loaded, but before the chart engine is instantiated.              */\n/* Directly modifying library files will prevent upgrades and the ability for ChartIQ to support your solution.          */\n/*************************************************************************************************************************/\n/* eslint-disable no-extra-parens */\n\n\n\n\nlet __js_addons_animation_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Add-On that animates the chart.\n *\n * Requires `addOns.js`\n *\n * The chart is animated in three ways:\n * 1.  The current price pulsates\n * 2.  The current price appears to move smoothly from the previous price\n * 3.  The chart's y-axis smoothly expands/contracts when a new high or low is reached\n *\n * The following chart types are supported: line, mountain, baseline_delta.\n *\n * Chart aggregations such as Kagi, Renko, Range Bars, etc. are not supported.\n *\n * **Animation displays more gracefully when updates are sent into the chart one at a time using {@link CIQ.ChartEngine#updateChartData}\n * instead of in batches using a [QuoteFeed]{@link CIQ.ChartEngine#attachQuoteFeed}. Sending data in batches will produce a â€˜jumpingâ€™ effect.**\n *\n * By default, there will be a flashing beacon created using a canvas circle. If instead you want to use a custom animation beacon, you will be able to extend the functionality yourself as follows:\n * - In js/addOns.js, at the bottom of the CIQ.Animation function, there is an stx.append(\"draw\") function.\n * - Make a copy of this function so you can override the behavior.\n * - In there you will see it determine var x and y, which are the coordinates for the center of the beacon.\n * - At the bottom of this append function, we draw the beacon by using the Canvas arc() function to draw a circle and then fill() to make the circle solid.\n * - You can replace  the canvas circle with an image using [CanvasRenderingContext2D.drawImage()](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D#Drawing_images) .\n * - Example:\n *\n *   ```\n *   var image = document.getElementById('beacon'); // include a hidden image on your HTML\n *   context.drawImage(image, x-10, y-10, 20, 20); // add the image on the canvas. Offset the x and y values by the radius of the beacon.\n *   ```\n\n *\n * Animation Example <iframe width=\"800\" height=\"500\" scrolling=\"no\" seamless=\"seamless\" align=\"top\" style=\"float:top\" src=\"https://jsfiddle.net/chartiq/6fqw652z/embedded/result,js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"1\"></iframe>\n *\n * You can disable animation after each different [chart type is activated]{@link CIQ.ChartEngine#setChartType} by calling:\n * ```\n * stxx.mainSeriesRenderer.supportsAnimation=false;\n * ```\n * Keep in mind that changing to a different chart type, may once again enable animation. You can override this by [adding an event listener]{@link CIQ.ChartEngine#addEventListener} on [layout changes]{@link layoutEventListener}.\n *\n * @param {object} params The constructor parameters\n * @param {CIQ.ChartEngine} params.stx The chart object\n * @param {object} [params.animationParameters] Configuration parameters\n * @param {boolean} [params.animationParameters.stayPut=false] Set to true for last tick to stay in position it was scrolled and have rest of the chart move backwards as new ticks are added instead of having new ticks advance forward and leave the rest of the chart in place.\n * @param {number} [params.animationParameters.ticksFromEdgeOfScreen=5] Number of ticks from the right edge the chart should stop moving forward so the last tick never goes off screen (only applicable if stayPut=false)\n * @param {number} [params.animationParameters.granularity=1000000] Set to a value that will give enough granularity for the animation.  The larger the number the smaller the price jump between frames, which is good for charts that need a very slow smooth animation either because the price jumps between ticks are very small, or because the animation was set up to run over a large number of frames when instantiating the CIQ.EaseMachine.\n * @param {number} [params.animationParameters.tension=null] Splining tension for smooth curves around data points (range 0-1).\n * @param {CIQ.EaseMachine} params.easeMachine Override the default easeMachine.  Default is `new CIQ.EaseMachine(Math.easeOutCubic, 1000);`\n * @constructor\n * @name  CIQ.Animation\n * @since\n * - 3.0.0 Now part of addOns.js. Previously provided as a standalone animation.js file.\n * - 4.0.0 Beacon only flashes for line charts. On Candles or bars it is suppressed as it produces an unnatural effect.\n * - 7.0.2 Now takes one configuration object as its constructor. Must have a reference to a chart engine.\n * @example\n * \tnew CIQ.Animation({stx: stxx, animationParameters: {tension:0.3}});  //Default animation with splining tension of 0.3\n *\n */\nCIQ.Animation =\n\tCIQ.Animation ||\n\tfunction (config) {\n\t\tif (!config) throw new Error(\"Invalid constructor arguments.\");\n\t\tvar stx, animationParameters, easeMachine;\n\t\tif (config instanceof CIQ.ChartEngine) {\n\t\t\t// legacy constructor\n\t\t\tstx = arguments[0];\n\t\t\tanimationParameters = arguments[1];\n\t\t\teaseMachine = arguments[2];\n\t\t} else {\n\t\t\tstx = config.stx;\n\t\t\tanimationParameters = config.animationParameters;\n\t\t\teaseMachine = config.easeMachine;\n\t\t}\n\t\tif (!stx)\n\t\t\treturn console.warn(\n\t\t\t\t\"No CIQ.ChartEngine provided. Cannot properly create CIQ.Animation instance\"\n\t\t\t);\n\t\tvar params = {\n\t\t\tstayPut: false,\n\t\t\tticksFromEdgeOfScreen: 5,\n\t\t\tgranularity: 1000000\n\t\t};\n\t\tanimationParameters = CIQ.extend(params, animationParameters);\n\n\t\tif (params.tension) stx.chart.tension = animationParameters.tension;\n\t\tstx.tickAnimator =\n\t\t\teaseMachine || new CIQ.EaseMachine(Math.easeOutCubic, 1000);\n\t\tvar scrollAnimator = new CIQ.EaseMachine(Math.easeInOutCubic, 1000);\n\n\t\tvar flashingColors = [\"#0298d3\", \"#19bcfc\", \"#5dcffc\", \"#9ee3ff\"];\n\t\tvar flashingColorIndex = 0;\n\t\tvar flashingColorThrottle = 20;\n\t\tvar flashingColorThrottleCounter = 0;\n\n\t\tvar filterSession = false;\n\t\tvar nextBoundary = null;\n\n\t\tfunction initMarketSessionFlags() {\n\t\t\tfilterSession = false;\n\t\t\tnextBoundary = null;\n\t\t}\n\n\t\tstx.addEventListener([\"symbolChange\", \"layout\"], function (obj) {\n\t\t\tinitMarketSessionFlags();\n\t\t});\n\n\t\tstx.prepend(\"updateCurrentMarketData\", function (\n\t\t\tdata,\n\t\t\tchart,\n\t\t\tsymbol,\n\t\t\tparams\n\t\t) {\n\t\t\tif (!chart) chart = this.chart;\n\t\t\tif (\n\t\t\t\tparams &&\n\t\t\t\tparams.fromTrade &&\n\t\t\t\t(chart.closePendingAnimation || chart.closePendingAnimation === 0)\n\t\t\t) {\n\t\t\t\tparams.finalClose = chart.closePendingAnimation;\n\t\t\t}\n\t\t});\n\n\t\tstx.prepend(\"updateChartData\", function (appendQuotes, chart, params) {\n\t\t\tvar self = this;\n\t\t\tif (!chart) {\n\t\t\t\tchart = self.chart;\n\t\t\t}\n\t\t\tif (\n\t\t\t\t!chart ||\n\t\t\t\t!chart.defaultChartStyleConfig ||\n\t\t\t\tchart.defaultChartStyleConfig == \"none\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tif (params !== undefined) {\n\t\t\t\tif (params.animationEntry || params.secondarySeries) return;\n\t\t\t}\n\n\t\t\tif (!chart.dataSegment) return;\n\n\t\t\tfunction completeLastBar(record) {\n\t\t\t\tif (!chart.masterData) return;\n\t\t\t\tfor (var md = chart.masterData.length - 1; md >= 0; md--) {\n\t\t\t\t\tvar bar = chart.masterData[md];\n\t\t\t\t\tif (bar.Close || bar.Close === 0) {\n\t\t\t\t\t\tbar.Close = record.Close;\n\t\t\t\t\t\tif (record.LastSize) bar.LastSize = record.LastSize;\n\t\t\t\t\t\tif (record.LastTime) bar.LastTime = record.LastTime;\n\t\t\t\t\t\tself.updateCurrentMarketData({\n\t\t\t\t\t\t\tClose: bar.Close,\n\t\t\t\t\t\t\tDT: bar.DT,\n\t\t\t\t\t\t\tLastSize: bar.LastSize,\n\t\t\t\t\t\t\tLastTime: bar.LastTime\n\t\t\t\t\t\t});\n\t\t\t\t\t\tself.createDataSet(null, null, { appending: true });\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction unanimateScroll() {\n\t\t\t\tif (chart.animatingHorizontalScroll) {\n\t\t\t\t\tchart.animatingHorizontalScroll = false;\n\t\t\t\t\tself.micropixels = self.nextMicroPixels = self.previousMicroPixels; // <-- Reset self.nextMicroPixels here\n\t\t\t\t\tchart.lastTickOffset = 0;\n\t\t\t\t}\n\t\t\t\tif (chart.closePendingAnimation !== null) {\n\t\t\t\t\tvar close = chart.closePendingAnimation;\n\t\t\t\t\tchart.closePendingAnimation = null;\n\t\t\t\t\tcompleteLastBar({ Close: close });\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar tickAnimator = self.tickAnimator;\n\t\t\t// These chart types are the only types supported by animation\n\t\t\tvar supportedChartType =\n\t\t\t\tthis.mainSeriesRenderer && this.mainSeriesRenderer.supportsAnimation;\n\t\t\tif (supportedChartType) {\n\t\t\t\tif (!tickAnimator) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t\"Animation plug-in can not run because the tickAnimator has not been declared. See instructions in animation.js\"\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If symbol changes then reset all of our variables\n\t\t\t\tif (this.prevSymbol != chart.symbol) {\n\t\t\t\t\tthis.prevQuote = 0;\n\t\t\t\t\tchart.closePendingAnimation = null;\n\t\t\t\t\tthis.prevSymbol = chart.symbol;\n\t\t\t\t}\n\t\t\t\tunanimateScroll();\n\t\t\t\ttickAnimator.stop();\n\t\t\t\tif (appendQuotes.length > 2) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar newParams = CIQ.clone(params);\n\t\t\tif (!newParams) newParams = {};\n\t\t\tnewParams.animationEntry = true;\n\t\t\tnewParams.bypassGovernor = true;\n\t\t\tnewParams.noCreateDataSet = false;\n\t\t\tnewParams.appending = true;\n\t\t\t//newParams.allowReplaceOHL = true;\n\t\t\tnewParams.firstLoop = true;\n\t\t\tvar symbol = this.chart.symbol;\n\t\t\tvar period = this.layout.periodicity;\n\t\t\tvar interval = this.layout.interval;\n\t\t\tvar timeUnit = this.layout.timeUnit;\n\n\t\t\tfunction cb(quote, prevQuote, chartJustAdvanced) {\n\t\t\t\treturn function (newData) {\n\t\t\t\t\tvar newClose = newData.Close;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!chart.dataSet.length ||\n\t\t\t\t\t\tsymbol != chart.symbol ||\n\t\t\t\t\t\tperiod != self.layout.periodicity ||\n\t\t\t\t\t\tinterval != self.layout.interval ||\n\t\t\t\t\t\ttimeUnit != self.layout.timeUnit\n\t\t\t\t\t) {\n\t\t\t\t\t\t//console.log (\"---- STOP animating: Old\",symbol,' New : ',chart.symbol, Date())\n\t\t\t\t\t\ttickAnimator.stop();\n\t\t\t\t\t\tunanimateScroll();\n\t\t\t\t\t\treturn; // changed symbols mid animation\n\t\t\t\t\t}\n\t\t\t\t\tvar q = CIQ.clone(quote);\n\t\t\t\t\tq.Adj_Close = null; // Don't use this, it will mess up our calculated close\n\t\t\t\t\tq.Close =\n\t\t\t\t\t\tMath.round(newClose * animationParameters.granularity) /\n\t\t\t\t\t\tanimationParameters.granularity; //<<------ IMPORTANT! Use 1000000 for small price increments, otherwise animation will be in increments of .0001\n\t\t\t\t\t//q.Close = Math.round(newClose*chart.roundit)/chart.roundit; // to ensure decimal points don't go out too far for interim values\n\t\t\t\t\tif (chartJustAdvanced) {\n\t\t\t\t\t\tif (!q.Open && q.Open !== 0) q.Open = q.Close;\n\t\t\t\t\t\tif (!q.High && q.High !== 0) q.High = Math.max(q.Open, q.Close);\n\t\t\t\t\t\tif (!q.Low && q.Low !== 0) q.Low = Math.min(q.Open, q.Close);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (quote.Close > prevQuote.High) q.High = q.Close;\n\t\t\t\t\t\tif (quote.Close < prevQuote.Low) q.Low = q.Close;\n\t\t\t\t\t}\n\t\t\t\t\tif (chart.animatingHorizontalScroll) {\n\t\t\t\t\t\tself.micropixels = newData.micropixels;\n\t\t\t\t\t\tchart.lastTickOffset = newData.lineOffset;\n\t\t\t\t\t}\n\t\t\t\t\tnewParams.updateDataSegmentInPlace = !tickAnimator.hasCompleted;\n\t\t\t\t\t//console.log(\"animating: Old\",symbol,' New : ',chart.symbol);\n\t\t\t\t\tvar updateQuotes = [q];\n\t\t\t\t\t// Don't include previous quote if tick mode. It will append, duplicating the quote\n\t\t\t\t\tif (chartJustAdvanced && self.layout.interval !== \"tick\")\n\t\t\t\t\t\tupdateQuotes.unshift(prevQuote);\n\t\t\t\t\tself.updateChartData(updateQuotes, chart, newParams);\n\t\t\t\t\tnewParams.firstLoop = false;\n\t\t\t\t\tif (tickAnimator.hasCompleted) {\n\t\t\t\t\t\t//console.log( 'animator has completed') ;\n\t\t\t\t\t\t//self.pendingScrollAdvance=false;\n\t\t\t\t\t\t//var possibleYAxisChange = chart.animatingHorizontalScroll;\n\t\t\t\t\t\tunanimateScroll();\n\t\t\t\t\t\t/*if (possibleYAxisChange) { // <---- Logic no longer necessary\n\t\t\t\t\t\t // After completion, one more draw for good measure in case our\n\t\t\t\t\t\t // displayed high and low have changed, which would trigger\n\t\t\t\t\t\t // the y-axis animation\n\t\t\t\t\t\t setTimeout(function(){\n\t\t\t\t\t\t self.draw();\n\t\t\t\t\t\t }, 0);\n\t\t\t\t\t\t }*/\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (supportedChartType) {\n\t\t\t\tvar quote = appendQuotes[appendQuotes.length - 1];\n\t\t\t\tthis.prevQuote = this.currentQuote(); // <---- prevQuote logic has been changed to prevent forward/back jitter when more than one tick comes in between animations\n\t\t\t\tvar chartJustAdvanced = false; // When advancing, we need special logic to deal with the open\n\t\t\t\tvar dontScroll = false;\n\t\t\t\tif (period == 1 && appendQuotes.length == 2) {\n\t\t\t\t\t// Don't do this if consolidating\n\t\t\t\t\tthis.prevQuote = appendQuotes[0];\n\t\t\t\t\tvar dataSetLength = chart.dataSet.length;\n\t\t\t\t\tcompleteLastBar(this.prevQuote);\n\t\t\t\t\tif (dataSetLength == chart.dataSet.length) dontScroll = true;\n\t\t\t\t}\n\t\t\t\tif (!quote || !quote.Close || !this.prevQuote || !this.prevQuote.Close)\n\t\t\t\t\treturn false;\n\n\t\t\t\tif (this.extendedHours && chart.market.market_def) {\n\t\t\t\t\t// Filter out unwanted sessions\n\t\t\t\t\tvar dtToFilter = quote.DT;\n\t\t\t\t\tif (CIQ.ChartEngine.isDailyInterval(interval)) {\n\t\t\t\t\t\tfilterSession = !chart.market.isMarketDate(dtToFilter);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!nextBoundary || nextBoundary <= dtToFilter) {\n\t\t\t\t\t\t\tvar session = chart.market.getSession(dtToFilter);\n\t\t\t\t\t\t\tfilterSession =\n\t\t\t\t\t\t\t\tsession !== \"\" &&\n\t\t\t\t\t\t\t\t(!this.layout.marketSessions ||\n\t\t\t\t\t\t\t\t\t!this.layout.marketSessions[session]);\n\t\t\t\t\t\t\tnextBoundary = chart.market[\n\t\t\t\t\t\t\t\tfilterSession ? \"getNextOpen\" : \"getNextClose\"\n\t\t\t\t\t\t\t](dtToFilter);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (filterSession) {\n\t\t\t\t\t\tthis.draw();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar barSpan = period;\n\t\t\t\tif (interval == \"second\" || timeUnit == \"second\") barSpan *= 1000;\n\t\t\t\telse if (interval == \"minute\" || timeUnit == \"minute\") barSpan *= 60000;\n\t\t\t\tif (!isNaN(interval)) barSpan *= interval;\n\t\t\t\tif (interval == \"day\" || timeUnit == \"day\")\n\t\t\t\t\tchartJustAdvanced = quote.DT.getDate() != this.prevQuote.DT.getDate();\n\t\t\t\telse if (interval == \"week\" || timeUnit == \"week\")\n\t\t\t\t\tchartJustAdvanced =\n\t\t\t\t\t\tquote.DT.getDate() >= this.prevQuote.DT.getDate() + 7;\n\t\t\t\telse if (interval == \"month\" || timeUnit == \"month\")\n\t\t\t\t\tchartJustAdvanced =\n\t\t\t\t\t\tquote.DT.getMonth() != this.prevQuote.DT.getMonth();\n\t\t\t\telse\n\t\t\t\t\tchartJustAdvanced =\n\t\t\t\t\t\tquote.DT.getTime() >= this.prevQuote.DT.getTime() + barSpan;\n\n\t\t\t\tvar linearChart =\n\t\t\t\t\t!this.mainSeriesRenderer || !this.mainSeriesRenderer.standaloneBars;\n\n\t\t\t\tvar beginningOffset = 0;\n\t\t\t\tif (chartJustAdvanced) {\n\t\t\t\t\tif (this.animations.zoom.hasCompleted) {\n\t\t\t\t\t\tvar candleWidth = this.layout.candleWidth;\n\t\t\t\t\t\tif (chart.scroll <= chart.maxTicks) {\n\t\t\t\t\t\t\twhile (this.micropixels > 0) {\n\t\t\t\t\t\t\t\t// If micropixels is larger than a candle then scroll back further\n\t\t\t\t\t\t\t\tchart.scroll++;\n\t\t\t\t\t\t\t\tthis.micropixels -= candleWidth;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chart.scroll <= chart.maxTicks) {\n\t\t\t\t\t\t\tthis.previousMicroPixels = this.micropixels;\n\t\t\t\t\t\t\tthis.nextMicroPixels = this.micropixels + candleWidth;\n\t\t\t\t\t\t\tbeginningOffset = candleWidth * -1;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tchart.dataSegment.length <\n\t\t\t\t\t\t\t\t\tchart.maxTicks - animationParameters.ticksFromEdgeOfScreen &&\n\t\t\t\t\t\t\t\t!animationParameters.stayPut\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.nextMicroPixels = this.micropixels;\n\t\t\t\t\t\t\t\tchart.scroll++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchart.animatingHorizontalScroll = linearChart; // When the chart advances we also animate the horizontal scroll by incrementing micropixels\n\t\t\t\t\t\t\tchart.previousDataSetLength = chart.dataSet.length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (!dontScroll) chart.scroll++;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchart.closePendingAnimation = quote.Close;\n\t\t\t\tvar start =\n\t\t\t\t\tchartJustAdvanced && !linearChart ? quote.Open : this.prevQuote.Close;\n\t\t\t\ttickAnimator.run(\n\t\t\t\t\tcb(quote, CIQ.clone(this.prevQuote), chartJustAdvanced),\n\t\t\t\t\t{\n\t\t\t\t\t\tClose: start,\n\t\t\t\t\t\tmicropixels: this.nextMicroPixels,\n\t\t\t\t\t\tlineOffset: beginningOffset\n\t\t\t\t\t},\n\t\t\t\t\t{ Close: quote.Close, micropixels: this.micropixels, lineOffset: 0 }\n\t\t\t\t);\n\t\t\t\treturn true; // bypass default behavior in favor of animation\n\t\t\t}\n\t\t});\n\n\t\tstx.prepend(\"renderYAxis\", function (chart) {\n\t\t\tif (this.grabbingScreen || !this.isHome()) return;\n\t\t\t// When display style doesn't support animation\n\t\t\tvar supportedChartType =\n\t\t\t\tthis.mainSeriesRenderer && this.mainSeriesRenderer.supportsAnimation;\n\t\t\tif (!supportedChartType) return;\n\n\t\t\tvar panel = chart.panel;\n\t\t\tvar yAxis = panel.yAxis;\n\t\t\tif (CIQ.Comparison && yAxis.priceFormatter == CIQ.Comparison.priceFormat)\n\t\t\t\treturn; // too difficult to animate y-axis change when it changes on every tick due to percentage axis on comparison\n\n\t\t\tfunction closure(self) {\n\t\t\t\treturn function (values) {\n\t\t\t\t\tchart.animatedLow = values.low;\n\t\t\t\t\tchart.animatedHigh = values.high;\n\t\t\t\t\tself.draw();\n\t\t\t\t};\n\t\t\t}\n\t\t\t// initialize prev values\n\t\t\tif (!chart.prevLowValue && chart.prevLowValue !== 0) {\n\t\t\t\tchart.prevLowValue = chart.animatedLow = chart.lowValue;\n\t\t\t}\n\t\t\tif (!chart.prevHighValue && chart.prevHighValue !== 0) {\n\t\t\t\tchart.prevHighValue = chart.animatedHigh = chart.highValue;\n\t\t\t}\n\n\t\t\t// check for a change, if so we will spin off an animation\n\t\t\tif (!scrollAnimator.running) chart.animatingVerticalScroll = false;\n\t\t\tif (\n\t\t\t\tchart.prevLowValue >= chart.lowValue &&\n\t\t\t\tchart.prevHighValue <= chart.highValue\n\t\t\t) {\n\t\t\t\tif (chart.animatingVerticalScroll) {\n\t\t\t\t\tyAxis.highValue = chart.animatedHigh;\n\t\t\t\t\tyAxis.lowValue = chart.animatedLow;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (scrollAnimator.running) scrollAnimator.stop();\n\t\t\tif (!chart.lowValue && !chart.highValue) return; // chart just reset, don't animate yet\n\t\t\tvar prevLow = chart.prevLowValue,\n\t\t\t\tprevHigh = chart.prevHighValue;\n\t\t\tchart.prevLowValue = chart.lowValue;\n\t\t\tchart.prevHighValue = chart.highValue;\n\t\t\tchart.animatingVerticalScroll = true;\n\t\t\tscrollAnimator.run(\n\t\t\t\tclosure(this),\n\t\t\t\t{ low: prevLow, high: prevHigh },\n\t\t\t\t{ low: chart.lowValue, high: chart.highValue }\n\t\t\t);\n\n\t\t\tyAxis.lowValue = chart.animatedLow;\n\t\t\tyAxis.highValue = chart.animatedHigh;\n\t\t});\n\n\t\t/*stx.prepend(\"draw\", function() {\n\t\t\tif(this.chart.animatingVerticalScroll) {\n\t\t\t\tthis.renderYAxis(this.chart);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});*/\n\n\t\tstx.append(\"draw\", function () {\n\t\t\tif (filterSession) return;\n\t\t\tif (\n\t\t\t\tthis.chart.dataSet &&\n\t\t\t\tthis.chart.dataSet.length &&\n\t\t\t\tthis.mainSeriesRenderer &&\n\t\t\t\tthis.mainSeriesRenderer.supportsAnimation\n\t\t\t) {\n\t\t\t\tif (flashingColorThrottleCounter % flashingColorThrottle === 0) {\n\t\t\t\t\tflashingColorIndex++;\n\t\t\t\t\tflashingColorThrottleCounter = 0;\n\t\t\t\t}\n\t\t\t\tflashingColorThrottleCounter++;\n\n\t\t\t\tvar context = this.chart.context;\n\t\t\t\tvar panel = this.chart.panel;\n\t\t\t\tvar currentQuote = this.currentQuote();\n\t\t\t\tif (!currentQuote) return;\n\t\t\t\tvar price = currentQuote.Close;\n\t\t\t\tvar x = this.pixelFromTick(currentQuote.tick, this.chart);\n\t\t\t\tif (this.chart.lastTickOffset) x = x + this.chart.lastTickOffset;\n\t\t\t\tvar y = this.pixelFromPrice(price, panel);\n\t\t\t\tif (\n\t\t\t\t\tthis.chart.yAxis.left > x &&\n\t\t\t\t\tthis.chart.yAxis.top <= y &&\n\t\t\t\t\tthis.chart.yAxis.bottom >= y\n\t\t\t\t) {\n\t\t\t\t\tif (flashingColorIndex >= flashingColors.length)\n\t\t\t\t\t\tflashingColorIndex = 0;\n\t\t\t\t\tcontext.beginPath();\n\t\t\t\t\tcontext.moveTo(x, y);\n\t\t\t\t\tcontext.arc(\n\t\t\t\t\t\tx,\n\t\t\t\t\t\ty,\n\t\t\t\t\t\t2 + flashingColorIndex * 1.07,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tMath.PI * 2,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t);\n\t\t\t\t\tcontext.fillStyle = flashingColors[flashingColorIndex];\n\t\t\t\t\tcontext.fill();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n};\n\nlet __js_addons_continuousZoom_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n\t * Add-On that allows a \"continuous zoom\", changing periodicities as the maxTicks and/or candlewidth hits a set boundary.\n\t * \n\t * Although this feature is available for all chart styles, it shows best on continuous renderings such as lines and mountains, vs. candles and bars. \n\t * This is because some users may find the changes in candle width, that takes place as the same range is displayed in a different periodicity, unnatural. \n\t * The effect can be mitigated by increasing the number of boundaries so periodicities change more often, preventing large candle width changes; \n\t * and by using the periodicity roll up feature instead of fetching new data from a quote feed. See examples.\n\t * \n\t * See {@link CIQ.ChartEngine#setPeriodicity} and {@link CIQ.ChartEngine#createDataSet}\n\t *\n\t * Requires `addOns.js`\n\t *\n\t * The feature will not work without supplying at least one element within the periodicities array,\n\t * and at least one property within the boundaries object.\n\t *\n\t * @param {object} params Configuration parameters\n\t * @param {CIQ.ChartEngine} params.stx The chart object\n\t * @param {array} params.periodicities Set this array with eligible periodicities here, in any order. These will be the periodicities which will be used by the continuous zooming once a boundary is hit.\n\t * \t\t\t\t\t\t\t\t\t\tThe periodicities are objects with period, interval, [timeUnit] properties (see {@link CIQ.ChartEngine#setPeriodicity}).\n\t * @param {object} params.boundaries Optional boundary cases to trigger the periodicity change. Hitting a max boundary will switch to the next larger periodicity; hitting a min boundary will switch to the next smaller periodicity.\n\t * @param {number} [params.boundaries.maxCandleWidth] largest size of candle in pixels to display before switching\n\t * @param {number} [params.boundaries.minCandleWidth] smallest size of candle in pixels to display before switching\n\t * @param {number} [params.boundaries.maxTicks] most number of ticks to display before switching\n\t * @param {number} [params.boundaries.minTicks] least number of ticks to display before switching\n\t * @constructor\n\t * @name  CIQ.ContinuousZoom\n     * @since 7.0.0\n     * @example\n     * new CIQ.ContinuousZoom({\n     *\tstx: stxx,\n     *\tperiodicities:[\n     *\t\t{period:1,   interval:\"month\"},\n     *\t\t{period:1,   interval:\"day\"},\n     *\t\t{period:2,   interval:30},\n     *\t\t{period:1,   interval:5},\n     *\t\t{period:15,  interval:1,  timeUnit:\"second\"},\n     *\t\t{period:1,   interval:1,  timeUnit:\"second\"}\n     *\t],\n     *\tboundaries:{\n     *\t\tmaxCandleWidth: 100,\n     *\t\tminCandleWidth: 3,\n     *\t\tmaxTicks: 500,\n     *\t\tminTicks: 10\n     *\t}\n     * });\n     * @example\n//smother periodicity change by rolling daily into weekly and monthly. \n// Also try reusing the same interval data and have the chart roll it instead of fetching new data.\nstxx.dontRoll=false; \nnew CIQ.ContinuousZoom({\n    stx: stxx,\n    periodicities:[\n    \t// daily interval data\n        {period:1,   interval:\"month\"},\n        {period:2,   interval:\"week\"},\n        {period:1,   interval:\"week\"},\n        {period:3,   interval:\"day\"},\n        {period:1,   interval:\"day\"},\n        // 30 minute interval data\n        {period:16,   interval:30},\n        {period:8,   interval:30},\n        {period:4,   interval:30},\n        {period:2,   interval:30},\n        // one minute interval data\n        {period:30,   interval:1},\n        {period:15,   interval:1},\n        {period:10,   interval:1},\n        {period:5,   interval:1},\n        {period:2,   interval:1},\n        {period:1,   interval:1},\n        // one second interval data\n        {period:30,  interval:1,  timeUnit:\"second\"},\n        {period:15,  interval:1,  timeUnit:\"second\"},\n        {period:5,   interval:1,  timeUnit:\"second\"},\n        {period:2,   interval:1,  timeUnit:\"second\"},\n        {period:1,   interval:1,  timeUnit:\"second\"},\n    ],\n    boundaries:{\n        maxCandleWidth: 15,\n        minCandleWidth: 3\n   }\n});\n     */\nCIQ.ContinuousZoom =\n\tCIQ.ContinuousZoom ||\n\tfunction (params) {\n\t\tthis.update(params);\n\t\tthis.stx.continuousZoom = this;\n\n\t\t//Attaches SmartZoom button to HTML DOM inside .chartSize element\n\t\tthis.addSmartZoomButton = function () {\n\t\t\t// Don't add a button if one already exists\n\t\t\tvar smartZoomButton =\n\t\t\t\tthis.stx.registerChartControl &&\n\t\t\t\tthis.stx.registerChartControl(\n\t\t\t\t\t\"stx-smart-zoom\",\n\t\t\t\t\t\"SmartZoom\",\n\t\t\t\t\t(function (self) {\n\t\t\t\t\t\treturn function (e) {\n\t\t\t\t\t\t\tself.smartZoomToggle(e);\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t})(this)\n\t\t\t\t);\n\t\t\tif (smartZoomButton) {\n\t\t\t\t// Listen for a layout changed event and refresh the toggle state of the button\n\t\t\t\tthis.stx.addEventListener(\"layout\", function (event) {\n\t\t\t\t\tif (event.stx.layout.smartzoom === true) {\n\t\t\t\t\t\tsmartZoomButton.classList.add(\"active\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmartZoomButton.classList.remove(\"active\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// Piggyback off of symbolImport event to detect smartzoom set to false from layout import\n\t\t\t\tthis.stx.addEventListener(\"symbolImport\", function (event) {\n\t\t\t\t\tif (event.stx.layout.smartzoom === false)\n\t\t\t\t\t\tsmartZoomButton.classList.remove(\"active\");\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t//Click event handler for the Smart Zoom button. Sets smartzoom property of layout to its inverse\n\t\tthis.smartZoomToggle = function (e) {\n\t\t\tthis.smartZoomEnable(!this.stx.layout.smartzoom);\n\t\t};\n\n\t\t//Sets smartzoom property of layout and notifies attached ChartEngine of change\n\t\tthis.smartZoomEnable = function (state) {\n\t\t\tthis.stx.layout.smartzoom = state;\n\t\t\tthis.stx.changeOccurred(\"layout\");\n\t\t};\n\n\t\t// Add the SmartZoom button to chartControls\n\t\tthis.addSmartZoomButton();\n\t\t// Enable SmartZoom by default\n\t\tthis.smartZoomEnable(true);\n\t};\n\n/**\n * Updates continuous zoom parameters\n * @param  {object} params Configuration parameters.  See constructor for details\n * @memberof CIQ.ContinuousZoom\n * @since 7.0.0\n * @private\n */\nCIQ.ContinuousZoom.prototype.update = function (params) {\n\tif (!params) params = {};\n\tthis.stx = params.stx;\n\tthis.periodicities = params.periodicities;\n\tthis.boundaries = params.boundaries;\n};\n\n/**\n * Potentially performs a continuous zoom after a zoom event\n * @param  {boolean} [zoomOut] True for a zoomOut operation, otherwise zoomIn\n * @memberof CIQ.ContinuousZoom\n * @since 7.0.0\n * @private\n */\nCIQ.ContinuousZoom.prototype.execute = function (zoomOut) {\n\t// assign a weight to a periodicity setting, the higher the length, the higher the weight\n\tfunction valuate(periodicity) {\n\t\tvar period = periodicity.period || periodicity.periodicity,\n\t\t\tinterval = periodicity.interval,\n\t\t\ttimeUnit = periodicity.timeUnit || \"minute\";\n\t\tif (isNaN(interval)) {\n\t\t\ttimeUnit = interval;\n\t\t\tinterval = 1;\n\t\t}\n\t\tswitch (timeUnit) {\n\t\t\tcase \"month\":\n\t\t\t\tinterval *= 4.35; /* falls through */\n\t\t\tcase \"week\":\n\t\t\t\tinterval *= 7; /* falls through */\n\t\t\tcase \"day\":\n\t\t\t\tinterval *= 1440; /* falls through */\n\t\t\tcase \"minute\":\n\t\t\t\tinterval *= 60; /* falls through */\n\t\t\tcase \"second\":\n\t\t\t\tbreak;\n\t\t\tcase \"millisecond\":\n\t\t\t\tinterval /= 1000;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t\treturn period * interval;\n\t}\n\tif (!this.stx || !this.stx.layout.smartzoom) return;\n\tvar periodicities = this.periodicities,\n\t\tboundaries = this.boundaries,\n\t\tstx = this.stx,\n\t\tlayout = stx.layout,\n\t\tchart = stx.chart;\n\tif (!periodicities || !boundaries) return;\n\n\tif (\n\t\t(!zoomOut &&\n\t\t\tboundaries.maxCandleWidth &&\n\t\t\tlayout.candleWidth > boundaries.maxCandleWidth) ||\n\t\t(zoomOut &&\n\t\t\tboundaries.minCandleWidth &&\n\t\t\tlayout.candleWidth < boundaries.minCandleWidth) ||\n\t\t(!zoomOut && boundaries.minTicks && chart.maxTicks < boundaries.minTicks) ||\n\t\t(zoomOut && boundaries.maxTicks && chart.maxTicks > boundaries.maxTicks)\n\t) {\n\t\tvar next = { value: zoomOut ? Number.MAX_VALUE : 0 };\n\t\tvar myValue = valuate(layout);\n\t\tfor (var p = 0; p < periodicities.length; p++) {\n\t\t\tvar value = valuate(periodicities[p]);\n\t\t\tif (\n\t\t\t\t(value > myValue && value < next.value && zoomOut) ||\n\t\t\t\t(value < myValue && value > next.value && !zoomOut)\n\t\t\t) {\n\t\t\t\tnext = { value: value, periodicity: periodicities[p] };\n\t\t\t}\n\t\t}\n\t\tvar newPeriodicity = next.periodicity;\n\t\tif (newPeriodicity) {\n\t\t\tstx.setRange({\n\t\t\t\tdtLeft: chart.xaxis[0].DT,\n\t\t\t\tdtRight: chart.xaxis[chart.xaxis.length - 1].DT,\n\t\t\t\tdontSaveRangeToLayout: true,\n\t\t\t\tperiodicity: newPeriodicity\n\t\t\t});\n\t\t}\n\t}\n};\n\n};\n\nlet __js_addons_extendedHours_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Use this constructor to initialize filtering and visualization styles of extended hours by the use of shading and delimitation lines.\n *\n * Requires `addOns.js`.\n *\n * This visualization will only work if data for the corresponding sessions is provided from your quote feed and the market definitions have the corresponding entries.\n * See {@link CIQ.Market} for details on how to define extended (non-default) hours.\n *\n * By default all extended hour sessions are disabled unless explicitly enabled using {@link CIQ.ExtendedHours.prepare} or {@link CIQ.ExtendedHours.set}.\n *\n * All possible market sessions needed to be shaded at any given time should be enabled at once with this method.\n *\n * Your fetch should load the required data based on the `params.stx.layout.extended` and `params.stx.layout.marketSessions` settings.\n *\n * Remember that when `params.filter` is set to true, this module performs a filter of already loaded masterData when {@link CIQ.ExtendedHours.set} is invoked,\n * rather than calling {@link CIQ.ChartEngine#loadChart} to reload the data from the server every time you enable or disable this feature.\n * So you must always return all requested sessions on your fetch responses if this flag is set.\n *\n *CSS info:\n * - The styles for the shading of each session is determined by the corresponding CSS class in the form of \"stx_market_session.\"+session_name (Example: `stx_market_session.pre`)\n * - The divider line is determined by the CSS class \"stx_market_session.divider\".\n *\n * **Important:** This module must be initialized before {@link CIQ.ChartEngine#importLayout} or the sessions will not be able to be restored.\n *\n * Example <iframe width=\"800\" height=\"500\" scrolling=\"no\" seamless=\"seamless\" align=\"top\" style=\"float:top\" src=\"https://jsfiddle.net/chartiq/g2vvww67/embedded/result,js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"1\"></iframe>\n *\n * @param {object} params The constructor parameters\n * @param {CIQ.ChartEngine} [params.stx] The chart object\n * @param {boolean} [params.filter] Setting to true performs a filter of masterData when {@link CIQ.ExtendedHours.set} is invoked, rather than calling {@link CIQ.ChartEngine#loadChart} to reload the data from the server.\n * @param {string} [params.menuContextClass] A CSS class name used to query the menu DOM\n * \t\telement that contains the UI control for the extended hours add-on. In a multi-chart\n * \t\tdocument, the add-on is available only on charts that have a menu DOM element with\n * \t\tthe value for `menuContextClass` as a class attribute.\n *\n * @constructor\n * @name CIQ.ExtendedHours\n * @since\n * - 06-2016-02\n * - 3.0.0 Changed argument to an object to support `filter`.\n * - 3.0.0 No longer necessary to explicitly call new Chart to reload data. Instead call {@link CIQ.ExtendedHours.set} function.\n * - 5.0.0 No longer necessary to explicitly set `stx.layout.marketSessions` or `1stx.layout.extended` to manage sessions; instead call {@link CIQ.ExtendedHours.prepare} or {@link CIQ.ExtendedHours.set}.\n * - 8.0.0 Added `params.menuContextClass`.\n *\n * @example\n * // Call this only once to initialize the market sessions display manager.\n * new CIQ.ExtendedHours({stx:stxx, filter:true});\n\n * // By default all sessions are disabled unless explicitly enabled.\n * // This forces the extended hours sessions [\"pre\",\"post\"] to be enabled when the chart is initially loaded.\n * stxx.extendedHours.prepare(true);\n\n * // Now display your chart.\n * stxx.loadChart(stxx.chart.symbol, {}, function() {});\n\n * @example\n * // Once your chart is displayed, you can call this from any UI interface to turn on extended hours.\n * stx.extendedHours.set(true);\n\n * // Or call this from any UI interface to turn off extended hours.\n * stx.extendedHours.set(false);\n\n * @example\n * // CSS entries for a session divider and sessions named \"pre\" and \"post\".\n * .stx_market_session.divider {\n *     background-color: rgba(0,255,0,0.8);\n *     width: 1px;\n * }\n * .stx_market_session.pre {\n *     background-color: rgba(255,255,0,0.1);\n * }\n * .stx_market_session.post {\n *     background-color: rgba(0,0,255,0.2);\n * }\n */\nCIQ.ExtendedHours =\n\tCIQ.ExtendedHours ||\n\tfunction (params) {\n\t\tvar stx = params.stx;\n\t\tthis.filter = params.filter;\n\t\tif (!stx) {\n\t\t\t// backwards compatibility\n\t\t\tstx = params;\n\t\t\tthis.filter = false;\n\t\t}\n\t\tvar styles = {};\n\t\tthis.stx = stx;\n\t\tthis.stx.extendedHours = this;\n\n\t\tconst menuClass = `${\n\t\t\t(params.menuContextClass && \".\" + params.menuContextClass) || \"body\"\n\t\t} .extendedhours-ui`;\n\t\tCIQ.addInternalStylesheet(`${menuClass} { display: inherit }`, menuClass);\n\n\t\tstx.addEventListener(\"theme\", function (tObject) {\n\t\t\t// reinitialize the session colors after a theme change\n\t\t\tstyles = {};\n\t\t\tfor (var sess in stx.layout.marketSessions) {\n\t\t\t\tif (!styles.session) styles.session = {};\n\t\t\t\tstyles.session[sess] = stx.canvasStyle(\"stx_market_session \" + sess);\n\t\t\t}\n\t\t});\n\n\t\tstx.addEventListener(\"symbolChange\", function (tObject) {\n\t\t\t// check if extended hours exists for this security\n\t\t\tif (\n\t\t\t\ttObject.action == \"master\" &&\n\t\t\t\tstx.layout.extended &&\n\t\t\t\t!(stx.chart.market.market_def && stx.chart.market.sessions.length)\n\t\t\t) {\n\t\t\t\tCIQ.alert(\"There are no Extended Hours for this instrument.\");\n\t\t\t}\n\t\t});\n\n\t\t/**\n\t\t * Prepares the extended hours settings and classes for the session names enumerated in the arguments without actually displaying or loading the data.\n\t\t *\n\t\t * This method can be used to force a particular session to load by default by calling it before {@link CIQ.ChartEngine#loadChart}.\n\t\t * Otherwise the chart will be loaded with all sessions disabled until {@link CIQ.ExtendedHours.set} is invoked.\n\t\t *\n\t\t * {@link CIQ.ChartEngine#importLayout} will also call this method to ensure the sessions are restored as previously saved.\n\t\t *\n\t\t * @param  {boolean} enable Set to turn on/off the extended-hours visualization.\n\t\t * @param  {array} sessions The sessions to visualize when enable is true.  Any sessions previously visualized will be disabled.  If set to null, will default to [\"pre\",\"post\"].\n\t\t * @memberof CIQ.ExtendedHours\n\t\t * @method prepare\n\t\t * @since 5.0.0\n\t\t */\n\t\tthis.prepare = function (enable, sessions) {\n\t\t\tstx.layout.extended = enable;\n\t\t\tfor (var sess in stx.layout.marketSessions) {\n\t\t\t\tstyles.session = {};\n\t\t\t\tstx.chart.market.disableSession(sess);\n\t\t\t}\n\t\t\tstx.layout.marketSessions = {};\n\t\t\tif (enable) {\n\t\t\t\tif (!sessions) sessions = [\"pre\", \"post\"];\n\t\t\t\tif (sessions.length) {\n\t\t\t\t\tfor (var s = 0; s < sessions.length; s++) {\n\t\t\t\t\t\tstx.layout.marketSessions[sessions[s]] = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstx.layout.marketSessions = sessions;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (sess in stx.layout.marketSessions) {\n\t\t\t\tif (!styles.session) styles.session = {};\n\t\t\t\tstyles.session[sess] = stx.canvasStyle(\"stx_market_session \" + sess);\n\t\t\t\tstx.chart.market.disableSession(sess, true);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * gathers and renders the extended hours for the preset session names enumerated in prepare().\n\t\t * @param  {function} cb Optional callback function to be invoked once chart is reloaded with extended hours data.\n\t\t * @memberof CIQ.ExtendedHours\n\t\t * @method complete\n\t\t * @private\n\t\t * @since 5.0.0\n\t\t */\n\t\tthis.complete = function (cb) {\n\t\t\tstx.changeOccurred(\"layout\");\n\t\t\tif (!stx.chart.market.market_def) {\n\t\t\t\t// possibly a 24 hours Market. Not necessarily an error but nothing to do for ExtendedHours\n\t\t\t\tif (cb) cb();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.filter) {\n\t\t\t\tstx.createDataSet();\n\t\t\t\tstx.draw();\n\t\t\t\tif (cb) cb();\n\t\t\t} else {\n\t\t\t\tstx.loadChart(stx.chart.symbol, cb);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Turns on or off extended hours for the session names enumerated in the arguments.\n\t\t * @param  {boolean} enable Set to turn on/off the extended-hours visualization.\n\t\t * @param  {array} sessions The sessions to visualize when enable is true.  Any sessions previously visualized will be disabled.  If set to null, will default to [\"pre\",\"post\"].\n\t\t * @param  {function} cb Optional callback function to be invoked once chart is reloaded with extended hours data.\n\t\t * @memberof CIQ.ExtendedHours\n\t\t * @method set\n\t\t */\n\t\tthis.set = function (enable, sessions, cb) {\n\t\t\tthis.prepare(enable, sessions);\n\t\t\tthis.complete(cb);\n\t\t};\n\n\t\t// This injection shades the after hours portion of the chart for each yaxis.\n\t\t// Only the panel to which the yaxis belongs will get shading.\n\t\t// This means yaxes of overlays will bypass the shading block.\n\t\tthis.stx.append(\"drawYAxis\", function (panel, parameters) {\n\t\t\tif (!this.layout.extended) return;\n\t\t\tif (\n\t\t\t\tpanel.yAxis != parameters.yAxis ||\n\t\t\t\tpanel.shareChartXAxis === false ||\n\t\t\t\tpanel.hidden\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tvar chart = panel.chart;\n\t\t\tif (CIQ.ChartEngine.isDailyInterval(this.layout.interval)) return;\n\t\t\tstyles.divider = this.canvasStyle(\"stx_market_session divider\");\n\t\t\tif (styles.session) {\n\t\t\t\tvar m = chart.market;\n\t\t\t\tvar ranges = [];\n\t\t\t\tvar range = {};\n\t\t\t\tvar nextBoundary, thisSession;\n\t\t\t\tfor (var i = 0; i < chart.dataSegment.length; i++) {\n\t\t\t\t\tvar ds = chart.dataSegment[i];\n\t\t\t\t\tif (!ds || !ds.DT) continue;\n\t\t\t\t\tvar c = null;\n\t\t\t\t\tif (m.market_def) {\n\t\t\t\t\t\tif (!nextBoundary || nextBoundary <= ds.DT) {\n\t\t\t\t\t\t\tthisSession = m.getSession(ds.DT);\n\t\t\t\t\t\t\tvar filterSession =\n\t\t\t\t\t\t\t\tthisSession !== \"\" &&\n\t\t\t\t\t\t\t\t(!this.layout.marketSessions ||\n\t\t\t\t\t\t\t\t\t!this.layout.marketSessions[thisSession]);\n\t\t\t\t\t\t\tnextBoundary = m[filterSession ? \"getNextOpen\" : \"getNextClose\"](\n\t\t\t\t\t\t\t\tds.DT\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvar s = styles.session[thisSession];\n\t\t\t\t\tif (s) c = s.backgroundColor;\n\t\t\t\t\tif (range.color && range.color != c) {\n\t\t\t\t\t\tranges.push({\n\t\t\t\t\t\t\tstart: range.start,\n\t\t\t\t\t\t\tend: range.end,\n\t\t\t\t\t\t\tcolor: range.color\n\t\t\t\t\t\t});\n\t\t\t\t\t\trange = {};\n\t\t\t\t\t}\n\t\t\t\t\tif (c) {\n\t\t\t\t\t\tvar cw = this.layout.candleWidth;\n\t\t\t\t\t\tif (ds.candleWidth) cw = ds.candleWidth;\n\t\t\t\t\t\trange.end = this.pixelFromBar(i, chart) + cw / 2;\n\t\t\t\t\t\tif (!range.start && range.start !== 0)\n\t\t\t\t\t\t\trange.start = range.end - cw + 1;\n\t\t\t\t\t\trange.color = c;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trange = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (range.start || range.start === 0)\n\t\t\t\t\tranges.push({\n\t\t\t\t\t\tstart: range.start,\n\t\t\t\t\t\tend: range.end,\n\t\t\t\t\t\tcolor: range.color\n\t\t\t\t\t});\n\t\t\t\tvar noDashes = CIQ.isTransparent(styles.divider.backgroundColor);\n\t\t\t\tvar dividerLineWidth = styles.divider.width.replace(/px/g, \"\");\n\t\t\t\tvar dividerStyle = {\n\t\t\t\t\ty0: panel.bottom,\n\t\t\t\t\ty1: panel.top,\n\t\t\t\t\tcolor: styles.divider.backgroundColor,\n\t\t\t\t\ttype: \"line\",\n\t\t\t\t\tcontext: chart.context,\n\t\t\t\t\tconfineToPanel: panel,\n\t\t\t\t\tpattern: \"dashed\",\n\t\t\t\t\tlineWidth: dividerLineWidth,\n\t\t\t\t\tdeferStroke: true\n\t\t\t\t};\n\t\t\t\tthis.startClip(panel.name);\n\t\t\t\tchart.context.beginPath();\n\t\t\t\tif (stx.highlightedDraggable) chart.context.globalAlpha *= 0.3;\n\t\t\t\tfor (i = 0; i < ranges.length; i++) {\n\t\t\t\t\tchart.context.fillStyle = ranges[i].color;\n\t\t\t\t\tif (!noDashes && ranges[i].start > chart.left)\n\t\t\t\t\t\tthis.plotLine(\n\t\t\t\t\t\t\tCIQ.extend(\n\t\t\t\t\t\t\t\t{ x0: ranges[i].start, x1: ranges[i].start },\n\t\t\t\t\t\t\t\tdividerStyle\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\tchart.context.fillRect(\n\t\t\t\t\t\tranges[i].start,\n\t\t\t\t\t\tpanel.top,\n\t\t\t\t\t\tranges[i].end - ranges[i].start,\n\t\t\t\t\t\tpanel.bottom - panel.top\n\t\t\t\t\t);\n\t\t\t\t\tif (!noDashes && ranges[i].end < chart.right)\n\t\t\t\t\t\tthis.plotLine(\n\t\t\t\t\t\t\tCIQ.extend({ x0: ranges[i].end, x1: ranges[i].end }, dividerStyle)\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tchart.context.stroke();\n\t\t\t\tthis.endClip();\n\t\t\t}\n\t\t});\n\t};\n\n};\n\nlet __js_addons_fullScreen_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Creates an add-on that sets the chart UI to full-screen mode. In full-screen mode, a class `full-screen` is added\n * to the context element used for styling. In addition, elements with the class `full-screen-hide` are hidden.\n * Elements with the class `full-screen-show` that are normally hidden are shown.\n *\n * Requires `addOns.js`.\n *\n * ![Full-screen display](./img-Full-Screen-Chart.png)\n *\n * @param {object} params Configuration parameters\n * @param {CIQ.ChartEngine} [params.stx] The chart object\n * @constructor\n * @name CIQ.FullScreen\n * @example\n * \tnew CIQ.FullScreen({stx:stxx});\n * @since 7.3.0\n */\nCIQ.FullScreen =\n\tCIQ.FullScreen ||\n\tfunction (params) {\n\t\tif (!params) params = {};\n\t\tif (!params.stx) {\n\t\t\tconsole.warn(\"The Full Screen addon requires an stx parameter\");\n\t\t\treturn;\n\t\t}\n\t\tthis.stx = params.stx;\n\t\tthis.stx.fullScreen = this;\n\t\tthis.fullScreenButton = null;\n\t\tthis.fullScreenState = false;\n\n\t\t//Attaches FullScreen button to HTML DOM inside .chartSize element\n\t\tthis.addFullScreenButton = function () {\n\t\t\tif (this.stx.registerChartControl)\n\t\t\t\tthis.fullScreenButton = this.stx.registerChartControl(\n\t\t\t\t\t\"stx-full-screen\",\n\t\t\t\t\t\"Full Screen\",\n\t\t\t\t\t(function (self) {\n\t\t\t\t\t\treturn function (e) {\n\t\t\t\t\t\t\tself.fullScreenToggle(e);\n\t\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t})(this)\n\t\t\t\t);\n\t\t};\n\n\t\t//Click event handler for the Full Screen button.\n\t\tthis.fullScreenToggle = function (e) {\n\t\t\t// First check for availability of the requestFullScreen function\n\t\t\tif (\n\t\t\t\tdocument.documentElement.requestFullscreen ||\n\t\t\t\tdocument.documentElement.webkitRequestFullscreen ||\n\t\t\t\tdocument.documentElement.mozRequestFullscreen ||\n\t\t\t\tdocument.documentElement.msRequestFullscreen\n\t\t\t) {\n\t\t\t\t// Check if full screen is already enabled\n\t\t\t\tif (this.getFullScreenElement()) {\n\t\t\t\t\tif (document.exitFullscreen) document.exitFullscreen();\n\t\t\t\t\telse if (document.webkitExitFullscreen)\n\t\t\t\t\t\tdocument.webkitExitFullscreen();\n\t\t\t\t\telse if (document.mozCancelFullScreen) document.mozCancelFullScreen();\n\t\t\t\t\telse if (document.msExitFullscreen) document.msExitFullscreen();\n\t\t\t\t} else {\n\t\t\t\t\t// requestFullscreen methods need to be checked for again here because the browser will not allow the method to be stored in a local var\n\t\t\t\t\tif (document.documentElement.requestFullscreen)\n\t\t\t\t\t\tdocument.documentElement.requestFullscreen();\n\t\t\t\t\telse if (document.documentElement.webkitRequestFullscreen)\n\t\t\t\t\t\tdocument.documentElement.webkitRequestFullscreen();\n\t\t\t\t\telse if (document.documentElement.mozRequestFullscreen)\n\t\t\t\t\t\tdocument.documentElement.mozRequestFullscreen();\n\t\t\t\t\telse if (document.documentElement.msRequestFullscreen)\n\t\t\t\t\t\tdocument.documentElement.msRequestFullscreen();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//If the full screen api isn't available, manually trigger the fullScreen styling\n\t\t\t\tthis.fullScreenState = !this.fullScreenState;\n\t\t\t\tthis.fullScreenRender();\n\t\t\t}\n\t\t};\n\n\t\t// Append/remove full-screen class to context or body and update button state\n\t\tthis.fullScreenRender = function () {\n\t\t\tvar containerElement = null;\n\t\t\tcontainerElement = CIQ.findClosestParent(\n\t\t\t\tthis.stx.container,\n\t\t\t\t\"*[cq-context], cq-context, body\"\n\t\t\t);\n\t\t\tif (containerElement) {\n\t\t\t\tif (this.fullScreenState === true) {\n\t\t\t\t\tif (this.fullScreenButton)\n\t\t\t\t\t\tthis.fullScreenButton.classList.add(\"active\");\n\t\t\t\t\tcontainerElement.classList.add(\"full-screen\");\n\t\t\t\t} else {\n\t\t\t\t\tif (this.fullScreenButton)\n\t\t\t\t\t\tthis.fullScreenButton.classList.remove(\"active\");\n\t\t\t\t\tcontainerElement.classList.remove(\"full-screen\");\n\t\t\t\t}\n\t\t\t\t// Trigger a resize event to update the chart size\n\t\t\t\twindow.dispatchEvent(new Event(\"resize\"));\n\t\t\t}\n\t\t};\n\n\t\t//Handle full screen change\n\t\tthis.onFullScreenChange = function () {\n\t\t\tif (this.getFullScreenElement()) {\n\t\t\t\tthis.fullScreenState = true;\n\t\t\t} else {\n\t\t\t\tthis.fullScreenState = false;\n\t\t\t}\n\t\t\tthis.fullScreenRender();\n\t\t};\n\n\t\tthis.getFullScreenElement = function () {\n\t\t\treturn (\n\t\t\t\tdocument.fullscreenElement ||\n\t\t\t\tdocument.webkitCurrentFullScreenElement ||\n\t\t\t\tdocument.mozFullScreenElement ||\n\t\t\t\tdocument.msFullscreenElement\n\t\t\t);\n\t\t};\n\n\t\tdocument.addEventListener(\n\t\t\t\"fullscreenchange\",\n\t\t\tthis.onFullScreenChange.bind(this),\n\t\t\tfalse\n\t\t);\n\t\tdocument.addEventListener(\n\t\t\t\"webkitfullscreenchange\",\n\t\t\tthis.onFullScreenChange.bind(this),\n\t\t\tfalse\n\t\t);\n\t\tdocument.addEventListener(\n\t\t\t\"mozfullscreenchange\",\n\t\t\tthis.onFullScreenChange.bind(this),\n\t\t\tfalse\n\t\t);\n\t\tdocument.addEventListener(\n\t\t\t\"MSFullscreenChange\",\n\t\t\tthis.onFullScreenChange.bind(this),\n\t\t\tfalse\n\t\t);\n\n\t\t// Add the FullScreen button to chartControls\n\t\tthis.addFullScreenButton();\n\t};\n\n};\n\nlet __js_addons_inactivityTimer_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Add-On that puts the chart into \"sleep mode\" after a period of inactivity.\n *\n * Requires `addOns.js`\n *\n * In sleep mode, a class \"ciq-sleeping\" will be added to the body.  This will dim out the chart.\n * Sleep mode is ended when interaction with the chart is detected.\n *\n * @param {object} params Configuration parameters\n * @param {CIQ.ChartEngine} [params.stx] The chart object\n * @param {number} [params.minutes] Inactivity period in _minutes_.  Set to 0 to disable the sleep mode.\n * @param {number} [params.interval] Sleeping quote update interval in _seconds_.  During sleep mode, this is used for the update loop.\n * \t\t\t\t\t\t\t\t\tSet to non-zero positive number or defaults to 60.\n * @param {function} [params.wakeCB] Optional callback function after waking\n * @param {function} [params.sleepCB] Optional callback function after sleeping\n * @constructor\n * @name  CIQ.InactivityTimer\n * @since 3.0.0\n * @example\n * \tnew CIQ.InactivityTimer({stx:stxx, minutes:30, interval:15});  //30 minutes of inactivity will put chart into sleep mode, updating every 15 seconds\n *\n */\nCIQ.InactivityTimer =\n\tCIQ.InactivityTimer ||\n\tfunction (params) {\n\t\tif (!params.minutes) return;\n\t\tif (!params.interval || params.interval < 0) params.interval = 60;\n\t\tthis.stx = params.stx;\n\t\tthis.timeout = params.minutes;\n\t\tthis.interval = params.interval;\n\t\tthis.wakeCB = params.wakeCB;\n\t\tthis.sleepCB = params.sleepCB;\n\t\tthis.sleepTimer = null;\n\t\tthis.sleeping = false;\n\t\tthis.last = new Date().getTime();\n\t\tthis.wakeChart = function () {\n\t\t\tclearTimeout(this.sleepTimer);\n\t\t\tthis.last = new Date().getTime();\n\t\t\tif (this.sleeping) {\n\t\t\t\tif (this.stx.quoteDriver) this.stx.quoteDriver.updateChartLoop();\n\t\t\t\tthis.sleeping = false;\n\t\t\t\tdocument.body.classList.remove(\"ciq-sleeping\");\n\t\t\t}\n\t\t\tthis.sleepTimer = setTimeout(\n\t\t\t\tthis.sleepChart.bind(this),\n\t\t\t\tthis.timeout * 60000\n\t\t\t);\n\t\t\tif (this.wakeCB) this.wakeCB();\n\t\t};\n\t\tthis.sleepChart = function () {\n\t\t\tif (!this.sleeping) {\n\t\t\t\tif (this.stx.quoteDriver)\n\t\t\t\t\tthis.stx.quoteDriver.updateChartLoop(this.interval);\n\t\t\t\tthis.sleeping = true;\n\t\t\t\tdocument.body.classList.add(\"ciq-sleeping\");\n\t\t\t}\n\t\t\tif (this.sleepCB) this.sleepCB();\n\t\t};\n\t\t$(document).on(\n\t\t\t\"mousemove mousedown touchstart touchmove pointerdown pointermove keydown wheel\",\n\t\t\t$(\"body\"),\n\t\t\t(function (self) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tself.wakeChart();\n\t\t\t\t};\n\t\t\t})(this)\n\t\t);\n\t\tthis.wakeChart();\n\t};\n\n};\n\nlet __js_addons_outliers_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Creates the outliers add-on which scales the y-axis to the main trend, hiding outlier\n * values. Markers are placed at the location of the outlier values enabling the user to\n * restore the full extent of the y-axis by selecting the markers.\n *\n * Requires *js/addOns.js*.\n *\n * ![Chart with hidden outliers](./img-Chart-with-Hidden-Outliers.png \"Chart with hidden outliers\")\n *\n * @param {object} params Configuration parameters.\n * @param {CIQ.ChartEngine} [params.stx] A reference to the chart object.\n * @param {number} [params.multiplier=3] Sets the threshold for outliers by multiplying the\n * \t\tnormal data range. The default value hides only extreme outliers.\n * @param {Array} [params.altColors] An array of hexadecimal color values used to style\n * \t\toutlier markers when multiple y-axes share the same panel. Markers for the first\n * \t\tadditional y-axis are styled with the value at index 0; markers for the second\n * \t\tadditional y-axis, the value at index 1; and so forth. If not provided, a default\n * \t\tarray of colors is assigned.\n * @param {string} [params.menuContextClass] A CSS class name used to query the menu DOM element\n * \t\tthat contains the UI control for the outliers add-on. In a multi-chart document, the\n * \t\tadd-on is available only on charts that have a menu DOM element with the value for\n * \t\t`menuContextClass` as a class attribute.\n *\n * @constructor\n * @name CIQ.Outliers\n * @since\n * - 7.5.0\n * - 8.0.0 Added `params.altColors` and `params.menuContextClass`.\n *\n * @example\n * new CIQ.Outliers({stx:stxx});\n */\nCIQ.Outliers =\n\tCIQ.Outliers ||\n\tfunction (params) {\n\t\tif (!params) params = {};\n\t\tif (!params.stx) {\n\t\t\tconsole.warn(\"The Outliers addon requires an stx parameter\");\n\t\t\treturn;\n\t\t}\n\t\t// Set default marker colors\n\t\tif (!Array.isArray(params.altColors)) {\n\t\t\tparams.altColors = [\n\t\t\t\t\"#323390\",\n\t\t\t\t\"#66308f\",\n\t\t\t\t\"#0073ba\",\n\t\t\t\t\"#f4932f\",\n\t\t\t\t\"#0056a4\",\n\t\t\t\t\"#00a99c\",\n\t\t\t\t\"#00a553\",\n\t\t\t\t\"#ea1d2c\",\n\t\t\t\t\"#e9088c\",\n\t\t\t\t\"#fff126\",\n\t\t\t\t\"#912a8e\",\n\t\t\t\t\"#ee652e\",\n\t\t\t\t\"#00afed\",\n\t\t\t\t\"#8ec648\"\n\t\t\t];\n\t\t}\n\t\tthis.stx = params.stx;\n\t\tthis.stx.outliers = this;\n\n\t\tthis.multiplier = params.multiplier || 3; // Default to 3 for extreme outliers\n\t\tthis.altColors = params.altColors;\n\n\t\tthis.axisData = {};\n\n\t\t// Listen for a layout changed event and reset the markers\n\t\tthis.stx.addEventListener(\"layout\", function (event) {\n\t\t\tObject.keys(event.stx.outliers.axisData).forEach(\n\t\t\t\tfunction (key) {\n\t\t\t\t\tthis.removeAllMarkers(this.axisData[key]);\n\t\t\t\t\tdelete this.axisData[key];\n\t\t\t\t}.bind(event.stx.outliers)\n\t\t\t);\n\t\t});\n\n\t\t// Enable the menu item\n\t\tconst menuClass = `${\n\t\t\t(params.menuContextClass && \".\" + params.menuContextClass) || \"body\"\n\t\t} .outliers-ui`;\n\t\tCIQ.addInternalStylesheet(`${menuClass} { display: inherit }`, menuClass);\n\n\t\t/**\n\t\t * Checks for outlier values in `dataSet`, and adds outlier markers (data point markers\n\t\t * and axis markers) to `axis`.\n\t\t *\n\t\t * @param {Array} dataSet An array of objects of the form `{value: Number, quote: Object}`.\n\t\t * \t\tEach object contains a value and its associated quote. The value is checked to\n\t\t * \t\tdetermine whether it is an outlier of the data set. When checking more than one\n\t\t * \t\tvalue for a quote (such as an OHLC quote), each value is included in a separate\n\t\t * \t\tobject; for example, `[{value: open, quote: quote}, {value: high, quote: quote},\n\t\t * \t\t{value: low, quote: quote}, {value: close, quote: quote}...]`.\n\t\t * @param {object} panel The panel where `dataSet` is rendered.\n\t\t * @param {object} axis The y-axis against which `dataSet` is rendered. **Note:** Charts\n\t\t * \t\tand panels can have multiple y-axes; each y-axis has its own set of outlier\n\t\t * \t\tmarkers based on the data rendered on the axis.\n\t\t * @return {Array} A tuple consisting of the outlier minimum and maximum &mdash; or trend\n\t\t * \t\tminimum and maximum, if no outliers are found &mdash; to be handled by the\n\t\t * \t\t{@link CIQ.ChartEngine#determineMinMax} method. See the return value of the\n\t\t * \t\t[find]{@link CIQ.Outliers#find} function for a description of outlier and trend\n\t\t * \t\tminimum and maximum.\n\t\t *\n\t\t * @alias processDataSet\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.processDataSet = function (dataSet, panel, axis) {\n\t\t\tif (!dataSet.length || dataSet.length <= 1) return false;\n\n\t\t\tvar result = [0, 0]; // Min/Max axis values to return\n\n\t\t\t// Create an axis reference if one does not exist\n\t\t\tif (!this.axisData[axis.name]) {\n\t\t\t\tvar markerColor = \"\";\n\t\t\t\tvar axisDepth = -1;\n\t\t\t\t// Check for another axis using this panel\n\t\t\t\tObject.keys(this.axisData).forEach(\n\t\t\t\t\tfunction (key) {\n\t\t\t\t\t\tif (this.axisData[key].panel.name == panel.name) {\n\t\t\t\t\t\t\taxisDepth++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this)\n\t\t\t\t);\n\t\t\t\tif (axisDepth > -1 && axisDepth < this.altColors.length)\n\t\t\t\t\tmarkerColor = this.altColors[axisDepth];\n\n\t\t\t\tthis.axisData[axis.name] = {\n\t\t\t\t\taxis: axis,\n\t\t\t\t\tpanel: panel,\n\t\t\t\t\tdisplayState: \"none\",\n\t\t\t\t\tisFlipped: false,\n\t\t\t\t\toriginalZoom: axis.zoom,\n\t\t\t\t\tmarkerColor: markerColor,\n\t\t\t\t\tmarkers: {},\n\t\t\t\t\taxisMarkers: {}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar currentAxis = this.axisData[axis.name];\n\t\t\t// Attach the min/max values to the current axis data\n\t\t\tObject.assign(currentAxis, this.find(dataSet));\n\n\t\t\t// Update/add necessary markers\n\t\t\tthis.refreshMarkerArray(currentAxis);\n\n\t\t\t// Update marker display and labels\n\t\t\tthis.refreshMarkers(currentAxis);\n\n\t\t\t// Return either trendMin or outlierMin based on the axis displayState\n\t\t\tif (\n\t\t\t\t(currentAxis.displayState === \"low\" ||\n\t\t\t\t\tcurrentAxis.displayState === \"all\") &&\n\t\t\t\tcurrentAxis.outlierMin !== null\n\t\t\t)\n\t\t\t\tresult[0] = currentAxis.outlierMin;\n\t\t\telse result[0] = currentAxis.trendMin;\n\t\t\t// Return either trendMax or outlierMax based on the axis displayState\n\t\t\tif (\n\t\t\t\t(currentAxis.displayState === \"high\" ||\n\t\t\t\t\tcurrentAxis.displayState === \"all\") &&\n\t\t\t\tcurrentAxis.outlierMax !== null\n\t\t\t)\n\t\t\t\tresult[1] = currentAxis.outlierMax;\n\t\t\telse result[1] = currentAxis.trendMax;\n\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Finds the outliers contained in `dataSet`.\n\t\t *\n\t\t * **Note:** This function may be overridden to provide a custom algorithm for finding\n\t\t * outliers.\n\t\t *\n\t\t * @param {Array} dataSet An array of objects of the form `{value: Number, quote: Object}`.\n\t\t * \t\tEach object contains a value and its associated quote. The value is checked to\n\t\t * \t\tdetermine whether it is an outlier of the data set. When checking more than one\n\t\t * \t\tvalue for a quote (such as an OHLC quote), each value is included in a separate\n\t\t * \t\tobject; for example, `[{value: open, quote: quote}, {value: high, quote: quote},\n\t\t * \t\t{value: low, quote: quote}, {value: close, quote: quote}...]`.\n\t\t * @return {object} An object of the form:\n\t\t * ```\n\t\t * {\n\t\t * \t// Minimum and maximum threshold values of dataSet to be considered an outlier.\n\t\t * \tminValue: null,\n\t\t * \tmaxValue: null,\n\t\t * \t// Mininum and maximum values of dataSet that are not considered outliers.\n\t\t * \t// Will be the least and greatest values in dataSet if no outliers are found.\n\t\t * \ttrendMin: null,\n\t\t * \ttrendMax: null,\n\t\t * \t// Minimum and maximum values of dataSet that are considered outliers.\n\t\t * \t// Will remain null if no outliers are found.\n\t\t * \toutlierMin: null,\n\t\t * \toutlierMax: null,\n\t\t * \t// Array of individual outlier information for marker placement, in the format {DT:DateTime, value:Number, position:String}\n\t\t * \t// (position is either 'high' or 'low').\n\t\t * \tactiveOutliers: []\n\t\t * }\n\t\t * ```\n\t\t *\n\t\t * @alias find\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added return value.\n\t\t */\n\t\tthis.find = function (dataSet) {\n\t\t\tif (!dataSet.length || dataSet.length <= 0) return;\n\n\t\t\tvar createMarkerPlaceholder = function (data, position) {\n\t\t\t\treturn {\n\t\t\t\t\tquote: data.quote,\n\t\t\t\t\tDT: data.quote.DT,\n\t\t\t\t\tvalue: data.value,\n\t\t\t\t\tposition: position\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// The minimum and maximum threshold values to be considered an outlier.\n\t\t\tvar minValue = null;\n\t\t\tvar maxValue = null;\n\t\t\t// min/max values of available data that are not considered outliers. Will be the least and greatest values in the available data if no outliers are found.\n\t\t\tvar trendMin = null;\n\t\t\tvar trendMax = null;\n\t\t\t// min/max values of available data that are considered outliers. Will remain null if no outlier is found.\n\t\t\tvar outlierMin = null;\n\t\t\tvar outlierMax = null;\n\t\t\t// Array of outlier information in the format\n\t\t\t// {DT:DateTime, value:Number, position:String}\n\t\t\tvar activeOutliers = [];\n\n\t\t\tvar dataSorted = dataSet.slice();\n\t\t\tdataSorted.sort(function (a, b) {\n\t\t\t\treturn a.value - b.value;\n\t\t\t});\n\t\t\tvar dataLength = dataSorted.length;\n\n\t\t\t// Outlier threshold values are defined as more than the interquartile range above the third quartile\n\t\t\t// or below the first quartile, of the sorted dataSet, multiplied by the value of the\n\t\t\t// stxx.outlierMultiplier property.\n\t\t\tvar q1 = dataSorted[Math.floor(dataLength / 4)].value;\n\t\t\tvar q3 = dataSorted[Math.floor(dataLength * (3 / 4))].value;\n\t\t\tvar iqr = q3 - q1;\n\n\t\t\tminValue = q1 - iqr * this.multiplier;\n\t\t\tmaxValue = q3 + iqr * this.multiplier;\n\n\t\t\t// Loop through the sorted data and find the outliers as well as the trend min/max\n\t\t\tfor (var idx = 0; idx < dataLength; idx++) {\n\t\t\t\t// Attack the array from both ends\n\t\t\t\tvar dataLow = dataSorted[idx];\n\t\t\t\tvar dataHigh = dataSorted[dataLength - (idx + 1)];\n\n\t\t\t\t// Find and mark outliers. Existing merkers will be refreshed in setMarker.\n\t\t\t\tif (dataLow.value <= minValue)\n\t\t\t\t\tactiveOutliers.push(createMarkerPlaceholder(dataLow, \"low\"));\n\t\t\t\tif (dataHigh.value >= maxValue)\n\t\t\t\t\tactiveOutliers.push(createMarkerPlaceholder(dataHigh, \"high\"));\n\n\t\t\t\t// Find the first low value that's less than or equal to outlier threshold min\n\t\t\t\tif (outlierMin === null && dataLow.value <= minValue)\n\t\t\t\t\toutlierMin = dataLow.value;\n\t\t\t\t// Find the first high value that's greater than or equal to outlier threshold max\n\t\t\t\tif (outlierMax === null && dataHigh.value >= maxValue)\n\t\t\t\t\toutlierMax = dataHigh.value;\n\n\t\t\t\t// Find the first low value that's greater than the outlier threshold min\n\t\t\t\tif (trendMin === null && dataLow.value > minValue)\n\t\t\t\t\ttrendMin = dataLow.value;\n\t\t\t\t// Find the first high value that's less than the outlier threshold max\n\t\t\t\tif (trendMax === null && dataHigh.value < maxValue)\n\t\t\t\t\ttrendMax = dataHigh.value;\n\n\t\t\t\t// No need to loop through the entire array. Once the trend min/max are found we're done.\n\t\t\t\tif (trendMin !== null && trendMax !== null) break;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tminValue: minValue,\n\t\t\t\tmaxValue: maxValue,\n\t\t\t\ttrendMin: trendMin,\n\t\t\t\ttrendMax: trendMax,\n\t\t\t\toutlierMin: outlierMin,\n\t\t\t\toutlierMax: outlierMax,\n\t\t\t\tactiveOutliers: activeOutliers\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t\t * Updates the freshness status of outlier markers belonging to `targetAxis`.\n\t\t *\n\t\t * Sets the status to fresh if the markers represent data points in the `activeOutliers`\n\t\t * list of `targetAxis` or a marker is an axis marker for high or low outliers and high or\n\t\t * low outliers exist. (See the return value of the [find]{@link CIQ.Outliers#find}\n\t\t * function for a description of the `activeOutliers` list.)\n\t\t *\n\t\t * Adds new markers to `targetAxis` for data points in the `activeOutliers` list not\n\t\t * already represented by a marker (see [markOutlier]{@link CIQ.Outliers#markOutlier}).\n\t\t * Adds new axis markers if the data set rendered on `targetAxis` contains high or low\n\t\t * outliers and the respective axis marker does not exist (see\n\t\t * [markAxis]{@link CIQ.Outliers#markAxis}).\n\t\t *\n\t\t * Sets the status of all other markers belonging to `targetAxis` to stale, or unfresh\n\t\t * (these markers are ultimately removed).\n\t\t *\n\t\t * @param {object} targetAxis The y-axis for which the markers are refreshed.\n\t\t * \t\t**Note:** Charts and panels can have multiple y-axes, each with its own array of\n\t\t * \t\toutlier markers.\n\t\t *\n\t\t * @alias refreshMarkerArray\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.refreshMarkerArray = function (targetAxis) {\n\t\t\tthis.deprecateMarkers(targetAxis); // If a marker isn't refreshed below, it will be deleted in the next call\n\n\t\t\tvar targetMarkers = targetAxis.markers;\n\t\t\ttargetAxis.activeOutliers.forEach(\n\t\t\t\tfunction (outlier) {\n\t\t\t\t\tvar quoteTime = outlier.DT.getTime().toString();\n\t\t\t\t\t// Add a quote marker if there isn't one already\n\t\t\t\t\tif (!targetMarkers[quoteTime]) {\n\t\t\t\t\t\ttargetMarkers[quoteTime] = {\n\t\t\t\t\t\t\tisFresh: true,\n\t\t\t\t\t\t\ttype: \"quote\",\n\t\t\t\t\t\t\tvalue: outlier.value,\n\t\t\t\t\t\t\tmarker: this.markOutlier(outlier, outlier.position, targetAxis)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\t// Always refresh the status of the marker\n\t\t\t\t\ttargetMarkers[quoteTime].isFresh = true;\n\t\t\t\t}.bind(this)\n\t\t\t);\n\t\t\tif (targetAxis.outlierMax !== null) {\n\t\t\t\t// Add the high axis marker if there isn't one\n\t\t\t\tif (!targetMarkers.axisHigh) {\n\t\t\t\t\ttargetMarkers.axisHigh = {\n\t\t\t\t\t\tisFresh: true,\n\t\t\t\t\t\ttype: \"axis\",\n\t\t\t\t\t\tvalue: targetAxis.outlierMax,\n\t\t\t\t\t\tmarker: this.markAxis(\"high\", targetAxis)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Always refresh the status of the marker\n\t\t\t\ttargetMarkers.axisHigh.isFresh = true;\n\t\t\t}\n\t\t\tif (targetAxis.outlierMin !== null) {\n\t\t\t\t// Add the low axis marker if there isn't one\n\t\t\t\tif (!targetMarkers.axisLow) {\n\t\t\t\t\ttargetMarkers.axisLow = {\n\t\t\t\t\t\tisFresh: true,\n\t\t\t\t\t\ttype: \"axis\",\n\t\t\t\t\t\tvalue: targetAxis.outlierMin,\n\t\t\t\t\t\tmarker: this.markAxis(\"low\", targetAxis)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t// Always refresh the status of the marker\n\t\t\t\ttargetMarkers.axisLow.isFresh = true;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Sets the outlier display state, which determines whether to display outlier markers.\n\t\t *\n\t\t * @param {string} newState The intended display state; should be one of:\n\t\t * <ul>\n\t\t *\t\t<li>\"high\" &mdash; Show high outliers; hide high outlier markers.</li>\n\t\t *\t\t<li>\"low\" &mdash; Show low outliers; hide low outlier markers.</li>\n\t\t *\t\t<li>\"all\" &mdash; Show high and low outliers; hide high and low outlier markers.</li>\n\t\t *\t\t<li>\"none\" &mdash; Hide high and low outliers; show high and low outlier markers.</li>\n\t\t * </ul>\n\t\t * If none of the above is provided, \"none\" is assumed.\n\t\t * @param {object} targetAxis The y-axis on which the outlier state is set. **Note:** A\n\t\t * \t\tchart or panel can have multiple y-axes.\n\t\t *\n\t\t * @alias setDisplayState\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `targetAxis` parameter.\n\t\t */\n\t\tthis.setDisplayState = function (newState, targetAxis) {\n\t\t\tif (newState != \"high\" && newState != \"low\" && newState != \"all\")\n\t\t\t\tnewState = \"none\";\n\n\t\t\tvar displayState = newState;\n\t\t\t// Set the value of displayState to show the intended state, based on its existing state. This\n\t\t\t// allows the markers to toggle between states without concern for what is currently displayed.\n\t\t\t// For example: if the current display state is showing low outlier only, and the intent is to\n\t\t\t// now display high outliers as well, then the display state will change to 'all'.\n\t\t\t// This will toggle the high/low state off as well.\n\t\t\tif (targetAxis.displayState == \"all\" && newState == \"high\")\n\t\t\t\tdisplayState = \"low\";\n\t\t\telse if (targetAxis.displayState == \"all\" && newState == \"low\")\n\t\t\t\tdisplayState = \"high\";\n\t\t\telse if (targetAxis.displayState == \"high\" && newState == \"low\")\n\t\t\t\tdisplayState = \"all\";\n\t\t\telse if (targetAxis.displayState == \"low\" && newState == \"high\")\n\t\t\t\tdisplayState = \"all\";\n\t\t\telse if (targetAxis.displayState == newState) displayState = \"none\";\n\n\t\t\ttargetAxis.displayState = displayState;\n\t\t\t// Reset the axis zoom state\n\t\t\ttargetAxis.axis.zoom = targetAxis.originalZoom;\n\n\t\t\tthis.refreshMarkers(targetAxis);\n\t\t\tthis.stx.draw();\n\t\t};\n\n\t\t/**\n\t\t * Removes all markers from `targetAxis` that are no longer fresh; that is, markers that\n\t\t * do not represent data points in the current data set, or axis markers that are\n\t\t * irrelevant because high or low outliers no longer exist. Sets the status of all\n\t\t * remaining outlier markers to stale, or not fresh (the freshness status should\n\t\t * subsequently be reevaluated).\n\t\t *\n\t\t * @param {object} targetAxis The y-axis for which the markers are deprecated. **Note:**\n\t\t * \t\tA chart or panel can have multiple y-axes; each y-axis has its own outlier\n\t\t * \t\tmarkers based on the data rendered on the axis.\n\t\t *\n\t\t * @alias deprecateMarkers\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `targetAxis` parameter.\n\t\t */\n\t\tthis.deprecateMarkers = function (targetAxis) {\n\t\t\tvar removeMarker = function (marker) {\n\t\t\t\tif (marker.marker && !marker.isFresh) {\n\t\t\t\t\tif (marker.marker.remove) marker.marker.remove();\n\t\t\t\t\tmarker.marker = null;\n\t\t\t\t} else {\n\t\t\t\t\tmarker.isFresh = false;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Handle the outlier markers\n\t\t\tObject.keys(targetAxis.markers).forEach(\n\t\t\t\tfunction (key) {\n\t\t\t\t\tremoveMarker(this.markers[key]);\n\t\t\t\t\t// Remove the marker property if its marker has been removed\n\t\t\t\t\tif (!this.markers[key].marker) {\n\t\t\t\t\t\tdelete this.markers[key];\n\t\t\t\t\t}\n\t\t\t\t}.bind(targetAxis)\n\t\t\t);\n\t\t};\n\n\t\t/**\n\t\t * Removes all outlier markers from `targetAxis`, including data point markers and y-axis\n\t\t * markers.\n\t\t *\n\t\t * @param {object} targetAxis The y-axis from which the markers are removed. **Note:**\n\t\t * \t\tCharts and panels can have multiple y-axes, each with its own outlier markers.\n\t\t *\n\t\t * @alias removeAllMarkers\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `targetAxis` parameter.\n\t\t */\n\t\tthis.removeAllMarkers = function (targetAxis) {\n\t\t\tObject.keys(targetAxis.markers).forEach(function (key) {\n\t\t\t\tvar targetMarker = targetAxis.markers[key].marker;\n\t\t\t\tif (targetMarker) {\n\t\t\t\t\tif (targetMarker.remove) targetMarker.remove();\n\t\t\t\t\ttargetMarker = null;\n\t\t\t\t}\n\t\t\t\t// Remove the marker property if its marker has been removed\n\t\t\t\tif (!targetMarker) {\n\t\t\t\t\tdelete targetAxis.markers[key];\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Shows or hides outlier markers based on the display state.\n\t\t *\n\t\t * See [setDisplayState]{@link CIQ.Outliers#setDisplayState}.\n\t\t *\n\t\t * @alias updateMarkerVisibility\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 7.5.0\n\t\t */\n\t\tthis.updateMarkerVisibility = function () {\n\t\t\tObject.keys(this.markers).forEach(\n\t\t\t\tfunction (key) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.displayState == \"all\" ||\n\t\t\t\t\t\tthis.markers[key].marker.node.classList.contains(this.displayState)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.markers[key].marker.node.style.display = \"none\";\n\t\t\t\t\telse this.markers[key].marker.node.style.display = \"block\";\n\t\t\t\t}.bind(this)\n\t\t\t);\n\t\t};\n\n\t\t/**\n\t\t * Updates the position of the axis outlier marker represented by `node`.\n\t\t *\n\t\t * @param {HTMLElement} node The axis marker to position.\n\t\t * @param {object} targetAxis The y-axis on which the axis marker is positioned.\n\t\t *\n\t\t * @alias refreshAxisMarkers\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `targetAxis` parameter.\n\t\t */\n\t\tthis.refreshAxisMarkers = function (node, targetAxis) {\n\t\t\tvar isHigh = false;\n\t\t\tvar positionClass = \"low\";\n\t\t\tif (node.classList.contains(\"high\")) {\n\t\t\t\tisHigh = true;\n\t\t\t\tpositionClass = \"high\";\n\t\t\t}\n\t\t\tvar posTop = targetAxis.axis.top;\n\t\t\t// Set the low marker of reverse the value if the axis is flipped\n\t\t\tif (\n\t\t\t\t(!targetAxis.isFlipped && !isHigh) ||\n\t\t\t\t(targetAxis.isFlipped && isHigh)\n\t\t\t) {\n\t\t\t\tposTop = targetAxis.axis.bottom - 50;\n\t\t\t}\n\t\t\t// Overlap the markers in the center for nano size because it's all or nothing at that size.\n\t\t\tif (node.classList.contains(\"nano\")) {\n\t\t\t\tposTop = targetAxis.axis.top + targetAxis.axis.height / 2 - 22;\n\t\t\t}\n\n\t\t\tvar xFormLeft = Math.floor(targetAxis.axis.left).toString() + \"px\";\n\t\t\tvar xFormTop = Math.floor(posTop).toString() + \"px\";\n\t\t\t// Use the vlaue property instead\n\t\t\tvar labelPrice = isHigh ? targetAxis.outlierMax : targetAxis.outlierMin;\n\n\t\t\t// Set marker positioning relative to the y-axis\n\t\t\tnode.style.transform = \"translate(\" + xFormLeft + \", \" + xFormTop + \")\";\n\t\t\tnode.querySelector(\n\t\t\t\t\".outlier-value\"\n\t\t\t).innerText = this.stx.formatYAxisPrice(labelPrice);\n\t\t\t// Apply .right class when axis is on the left to right position child elements\n\t\t\tif (xFormLeft === \"0px\") node.classList.add(\"right\");\n\t\t\telse node.classList.remove(\"right\");\n\t\t};\n\n\t\t/**\n\t\t * Updates the display styles of all outlier markers belonging to `targetAxis`, including\n\t\t * data point markers and axis markers. Shows the markers if outliers are hidden and the\n\t\t * marked outliers exceed the bounds of `targetAxis`. Flips the markers if `targetAxis`\n\t\t * has been inverted (see [flipMarkers]{@link CIQ.Outliers#flipMarkers}).\n\t\t *\n\t\t * @param {object} targetAxis The y-axis on which the markers are refreshed. **Note:**\n\t\t * \t\tCharts and panels can have multiple y-axes, each with its own outlier markers.\n\t\t *\n\t\t * @alias refreshMarkers\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.refreshMarkers = function (targetAxis) {\n\t\t\tObject.keys(targetAxis.markers).forEach(\n\t\t\t\tfunction (targetAxis, key) {\n\t\t\t\t\tvar targetMarker = targetAxis.markers[key].marker;\n\t\t\t\t\tvar targetValue = targetAxis.markers[key].value;\n\t\t\t\t\tvar targetType = targetAxis.markers[key].type;\n\t\t\t\t\t// Check the marker value against the actual axis min/max. This accounts for yaxis scaling\n\t\t\t\t\t// in addition to the outlier display state.\n\t\t\t\t\tif (\n\t\t\t\t\t\t(targetValue > targetAxis.trendMax &&\n\t\t\t\t\t\t\ttargetAxis.axis.high >= targetValue) ||\n\t\t\t\t\t\t(targetValue < targetAxis.trendMin &&\n\t\t\t\t\t\t\ttargetAxis.axis.low <= targetValue)\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (targetType == \"quote\") {\n\t\t\t\t\t\t\ttargetMarker.node.style.display = \"none\";\n\t\t\t\t\t\t} else if (targetType == \"axis\") {\n\t\t\t\t\t\t\ttargetMarker.node.classList.add(\"compress\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (targetType == \"quote\") {\n\t\t\t\t\t\t\ttargetMarker.node.style.display = \"block\";\n\t\t\t\t\t\t} else if (targetType == \"axis\") {\n\t\t\t\t\t\t\ttargetMarker.node.classList.remove(\"compress\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (targetType == \"axis\") {\n\t\t\t\t\t\tthis.refreshAxisMarkers(targetMarker.node, targetAxis);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update the marker responsive style\n\t\t\t\t\tif (targetAxis.axis.height < 100)\n\t\t\t\t\t\ttargetMarker.node.classList.add(\"nano\");\n\t\t\t\t\telse targetMarker.node.classList.remove(\"nano\");\n\n\t\t\t\t\tif (targetAxis.axis.height < 250)\n\t\t\t\t\t\ttargetMarker.node.classList.add(\"micro\");\n\t\t\t\t\telse targetMarker.node.classList.remove(\"micro\");\n\t\t\t\t}.bind(this, targetAxis)\n\t\t\t);\n\n\t\t\t// Check for a change in the flipped state of the axis\n\t\t\tif (targetAxis.isFlipped !== targetAxis.axis.flipped)\n\t\t\t\tthis.flipMarkers(targetAxis);\n\t\t};\n\n\t\t/**\n\t\t * Places markers on the y-axis when high or low outliers exist.\n\t\t *\n\t\t * @param {string} position The position of the marker; either \"high\" or \"low\". If the\n\t\t * \t\tposition is \"high\", the marker is placed at the top of the axis; if \"low\", at the\n\t\t * \t\tbottom of the axis.\n\t\t * @param {object} targetAxis The y-axis on which the markers are placed. **Note:**\n\t\t * \t\tCharts and panels can have multiple y-axes, each with its own outlier markers.\n\t\t * @return {CIQ.Marker} The axis outlier marker, which is added to the display.\n\t\t *\n\t\t * @alias markAxis\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `position` and `targetAxis` parameters and return value.\n\t\t */\n\t\tthis.markAxis = function (position, targetAxis) {\n\t\t\t// Create a marker positioned on the Y axis and return it.\n\t\t\tvar axisMarker = document.createElement(\"div\");\n\t\t\taxisMarker.classList.add(\"outlier-sticker\", \"axis\", \"mini\", position);\n\t\t\taxisMarker.innerHTML =\n\t\t\t\t'<div class=\"expansion\"><div class=\"pill\"><div class=\"icon\"></div></div><div class=\"tick\"></div><span class=\"outlier-value\"></div><div class=\"compression\"><div class=\"pill\"><div class=\"icon\"></div></div></div></span>';\n\n\t\t\tthis.matchYAxisStyle(axisMarker);\n\t\t\tthis.setMarkerColor(axisMarker, targetAxis.markerColor);\n\n\t\t\tvar activate = this.handleMarkerClick.bind(\n\t\t\t\tthis,\n\t\t\t\tposition,\n\t\t\t\ttargetAxis,\n\t\t\t\taxisMarker\n\t\t\t);\n\t\t\taxisMarker.addEventListener(\"click\", activate);\n\t\t\taxisMarker.addEventListener(\"touchend\", activate);\n\n\t\t\treturn new CIQ.Marker({\n\t\t\t\tstx: this.stx,\n\t\t\t\txPositioner: \"none\",\n\t\t\t\tyPositioner: \"none\",\n\t\t\t\tlabel: \"expand\",\n\t\t\t\tpermanent: true,\n\t\t\t\tchartContainer: true,\n\t\t\t\tnode: axisMarker\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Adds an outlier marker to a tick (data point).\n\t\t *\n\t\t * @param {object} data Represents the tick that is marked as an outlier. Contains the\n\t\t * \t\toutlier value and its associated quote; for example,\n\t\t * \t\t`{value: Number, quote: Object}`.\n\t\t * @param {string} position The position of the marker; either \"high\" or \"low\". If the\n\t\t * \t\tposition is \"high\", the marker is placed at the top of the chart; if \"low\", at the\n\t\t * \t\tbottom of the chart.\n\t\t * @param {object} targetAxis The y-axis to which the marker is added. **Note:** A chart\n\t\t * \t\tor panel can have multiple y-axes; each y-axis has its own outlier markers.\n\t\t * @return {CIQ.Marker} The outlier marker, which is added to the display.\n\t\t *\n\t\t * @alias markOutlier\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Added `targetAxis` parameter.\n\t\t */\n\t\tthis.markOutlier = function (data, position, targetAxis) {\n\t\t\tif (!data) return;\n\t\t\tif (!targetAxis) targetAxis = { panel: this.stx.panels.chart };\n\t\t\tposition = position || \"high\";\n\n\t\t\t// Create a marker\n\t\t\tvar outlierMarker = document.createElement(\"div\");\n\t\t\toutlierMarker.classList.add(\"outlier-sticker\", \"quote\", \"mini\", position);\n\t\t\toutlierMarker.innerHTML =\n\t\t\t\t'<div class=\"pill\"><div class=\"icon\"></div></div><span class=\"outlier-value\">' +\n\t\t\t\tthis.stx.formatYAxisPrice(data.value, targetAxis.panel) +\n\t\t\t\t\"</span>\";\n\n\t\t\tthis.matchYAxisStyle(outlierMarker);\n\t\t\tthis.setMarkerColor(outlierMarker, targetAxis.markerColor);\n\n\t\t\tvar activate = this.handleMarkerClick.bind(\n\t\t\t\tthis,\n\t\t\t\tposition,\n\t\t\t\ttargetAxis,\n\t\t\t\toutlierMarker\n\t\t\t);\n\t\t\toutlierMarker.addEventListener(\"click\", activate);\n\t\t\toutlierMarker.addEventListener(\"touchend\", activate);\n\n\t\t\treturn new CIQ.Marker({\n\t\t\t\tstx: this.stx,\n\t\t\t\txPositioner: \"date\",\n\t\t\t\tyPositioner: position == \"high\" ? \"top\" : \"bottom\",\n\t\t\t\tx: data.quote.DT,\n\t\t\t\tpanelName: targetAxis.panel.name,\n\t\t\t\tnode: outlierMarker\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * Calls [setDisplayState]{@link CIQ.Outliers#setDisplayState} in response to selecting an\n\t\t * outlier marker.\n\t\t *\n\t\t * @param {string} position The position of the marker; either \"high\" or \"low\".\n\t\t * @param {object} targetAxis The y-axis that contains the selected marker. **Note:**\n\t\t * \t\tCharts and panels can have multiple y-axes; each y-axis has its own outlier\n\t\t * \t\tmarkers.\n\t\t * @param {HTMLElement} targetNode The selected outlier marker DOM node.\n\t\t *\n\t\t * @alias handleMarkerClick\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.handleMarkerClick = function (position, targetAxis, targetNode) {\n\t\t\tif (targetNode.classList.contains(\"nano\")) position = \"all\"; // not concerned about differentiation between high and low at the nano size\n\t\t\tthis.setDisplayState(position, targetAxis);\n\t\t\tthis.stx.draw();\n\t\t};\n\n\t\t/**\n\t\t * Sets the CSS style properties of the y-axis outlier marker to match the CSS styling of\n\t\t * the y-axis itself.\n\t\t *\n\t\t * @param {HTMLElement} node The y-axis marker to style.\n\t\t *\n\t\t * @alias matchYAxisStyle\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 7.5.0\n\t\t */\n\t\tthis.matchYAxisStyle = function (node) {\n\t\t\t// Apply styles from the yAxis\n\t\t\tif (this.stx.styles.stx_yaxis) {\n\t\t\t\tvar styles = this.stx.styles.stx_yaxis;\n\t\t\t\tnode.style.fontSize = styles.fontSize;\n\t\t\t\tnode.style.fontFamily = styles.fontFamily;\n\t\t\t\tnode.style.color = styles.color;\n\t\t\t\tnode.style.borderColor = styles.color;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Applies a background color to an outlier data point marker.\n\t\t *\n\t\t * @param {HTMLElement} node The outlier marker DOM node to which the background color is\n\t\t * \t\tapplied.\n\t\t * @param {string} color The hexadecimal color value set as the node background color.\n\t\t *\n\t\t * @alias setMarkerColor\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.setMarkerColor = function (node, color) {\n\t\t\tif (color == \"\") return;\n\t\t\t//Set marker color\n\t\t\tvar markerPills = node.querySelectorAll(\".pill\");\n\t\t\tfor (var markerIdx = 0; markerIdx < markerPills.length; markerIdx++) {\n\t\t\t\tmarkerPills[markerIdx].style.backgroundColor = color;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Repositions outlier markers from the top of the display to the bottom (or vice versa)\n\t\t * when the associated y-axis has been flipped (inverted).\n\t\t *\n\t\t * @param {object} targetAxis The y-axis that has been flipped.\n\t\t *\n\t\t * @alias flipMarkers\n\t\t * @memberOf CIQ.Outliers.prototype\n\t\t * @since 8.0.0\n\t\t */\n\t\tthis.flipMarkers = function (targetAxis) {\n\t\t\ttargetAxis.isFlipped = targetAxis.axis.flipped;\n\n\t\t\tObject.keys(targetAxis.markers).forEach(\n\t\t\t\tfunction (targetAxis, key) {\n\t\t\t\t\tvar targetMarker = targetAxis.markers[key].marker;\n\t\t\t\t\tvar targetValue = targetAxis.markers[key].value;\n\t\t\t\t\tvar targetType = targetAxis.markers[key].type;\n\t\t\t\t\t// Check for flipped state and add/remove flipped class\n\t\t\t\t\tif (targetAxis.isFlipped) {\n\t\t\t\t\t\ttargetMarker.node.classList.add(\"flipped\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargetMarker.node.classList.remove(\"flipped\");\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set Y positioning of quote markers\n\t\t\t\t\tif (targetType == \"quote\") {\n\t\t\t\t\t\tif (targetValue > targetAxis.trendMax) {\n\t\t\t\t\t\t\t// High marker\n\t\t\t\t\t\t\tif (targetAxis.isFlipped)\n\t\t\t\t\t\t\t\ttargetMarker.params.yPositioner = \"bottom\";\n\t\t\t\t\t\t\telse targetMarker.params.yPositioner = \"top\";\n\t\t\t\t\t\t} else if (targetValue < targetAxis.trendMin) {\n\t\t\t\t\t\t\t// Low marker\n\t\t\t\t\t\t\tif (targetAxis.isFlipped) targetMarker.params.yPositioner = \"top\";\n\t\t\t\t\t\t\telse targetMarker.params.yPositioner = \"bottom\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind(this, targetAxis)\n\t\t\t);\n\t\t};\n\n\t\tvar originalDetermineMinMax = CIQ.ChartEngine.prototype.determineMinMax.bind(\n\t\t\tthis.stx\n\t\t);\n\t\t/**\n\t\t * Overrides the default `CIQ.ChartEngine.prototype.determineMinMax` function when the\n\t\t * Outliers add-on is active. Injects the local {@link CIQ.Outliers#processDataSet}\n\t\t * function as a data filter and passes the filter along to the original `determineMinMax`\n\t\t * function (see below).\n\t\t *\n\t\t * @param {Array} quotes The array of quotes (typically\n\t\t * \t\t`CIQ.ChartEngine.chart.dataSegment`) to evaluate for minimum and maximum values.\n\t\t * @param {Array} fields A list of fields to compare.\n\t\t * @param {boolean|Array} [sum] If true, then compute maximum sum rather than the maximum\n\t\t * \t\tsingle value across all fields. If an array, compute sum over just the fields in\n\t\t * \t\tthe array.\n\t\t * @param {boolean} [bypassTransform] If true, bypass any transformations.\n\t\t * @param {number} [length] Specifies how many elements of the quotes array to process.\n\t\t * @param {boolean} [checkArray] If true, the type of the value used to determine the\n\t\t * \t\tmin/max is checked to ascertain whether it is an array; if so, the first element\n\t\t * \t\tof the array is retrieved for use in the min/max determination.\n\t\t * @param {CIQ.ChartEngine.Panel} [panel] A reference to the panel rendering the quotes.\n\t\t * @param {CIQ.ChartEngine.YAxis} [axis] A reference to the y-axis rendered for the quotes.\n\t\t * @param {Array} [filters] Array of functions to process the min/max values before\n\t\t * \treturning. Filter functions must return a valid min/max tuple or false.\n\t\t * @return {function} A reference to the original\n\t\t * \t\t`CIQ.ChartEngine.prototype.determineMinMax` library function.\n\t\t *\n\t\t * @memberof CIQ.ChartEngine\n\t\t * @since\n\t\t * - 7.5.0\n\t\t * - 8.0.0 Allow the `sum` parameter to be an array of valid fields to sum over.\n\t\t * \t\tAdded the `panel`, `axis`, and `filters` parameters.\n\t\t * @private\n\t\t */\n\t\tCIQ.ChartEngine.prototype.determineMinMax = function (\n\t\t\tquotes,\n\t\t\tfields,\n\t\t\tsum,\n\t\t\tbypassTransform,\n\t\t\tlength,\n\t\t\tcheckArray,\n\t\t\tpanel,\n\t\t\taxis,\n\t\t\tfilters\n\t\t) {\n\t\t\tif (!filters) filters = [];\n\t\t\tif (panel && axis && this.layout.outliers)\n\t\t\t\tfilters.push(this.outliers.processDataSet.bind(this.outliers));\n\t\t\treturn originalDetermineMinMax(\n\t\t\t\tquotes,\n\t\t\t\tfields,\n\t\t\t\tsum,\n\t\t\t\tbypassTransform,\n\t\t\t\tlength,\n\t\t\t\tcheckArray,\n\t\t\t\tpanel,\n\t\t\t\taxis,\n\t\t\t\tfilters\n\t\t\t);\n\t\t};\n\t};\n\n};\n\nlet __js_addons_plotComplementer_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Creates an add-on that enables a series to complement another series.\n *\n * ![Plot Complementer](./img-Data-Forecasting.png)\n *\n * The complementary series is a permanent fixture of the series which it complements. It moves in tandem with the series,\n * and gets removed with the series. In all other respects, though, it behaves like its own series. It shows separately in\n * the panel legend and plots using its own renderer.\n *\n * Charts can have multiple `PlotComplementer` instances. Each instance is attached to the chart engine as a member of a\n * `PlotComplementer` collection.\n *\n * Multiple `PlotComplementer` instances can be associated with a time series. To link a `PlotComplementer` to a series,\n * specify the series instrument in the `params.filter` function. See `[setQuoteFeed]{@link CIQ.PlotComplementer#setQuoteFeed}`.\n *\n * **Note:** The series created by this add-on is not exported with the layout, since it is created in tandem with the series\n * it complements. Currently, this feature works only with non-comparison series.\n *\n * @param {object} params Configuration parameters.\n * @param {CIQ.ChartEngine} params.stx The chart object.\n * @param {string} [params.id] Unique key used by the add-on to identify itself. If not supplied, a random key is chosen.\n * @param {object} [params.quoteFeed] Attaches the quote feed to the quote driver to satisfy any quote requests for any\n * \t\t\t\t\tseries created by the add-on.\n * @param {object} [params.behavior] Used as the behavior for the quote feed supplied in this parameter list.\n * @param {function} [params.filter] Used as the filter for the quote feed supplied in this parameter list.\n * \t\t\t\t\tSee `[setQuoteFeed]{@link CIQ.PlotComplementer#setQuoteFeed}`.\n * @param {object} [params.decorator] Container object for the `symbol` and `display` properties. The `decorator` provides the\n * \t\t\t\t\tlabel (`symbol`) for the complementary series and a short description (`display`) that is appended to\n * \t\t\t\t\tthe label; for example:\n * ```javascript\n * decorator: {symbol:\"_fcst\", display:\" Forecast\"}\n * ```\n * @param {string} [params.decorator.symbol] Adds this string onto the ID when creating the complementary series.\n * \t\t\t\t\tOtherwise, a unique ID is used.\n * @param {string} [params.decorator.display] Customizes the display value of the series.\n * @param {object} [params.renderingParameters={chartType:\"line\", width:1, opacity:0.5}] A collection of parameters\n * \t\t\t\t\tthat override the default rendering parameters. The `renderingParameters` object can be set or changed\n * \t\t\t\t\tat any time. The default parameters can be restored by calling\n * \t\t\t\t\t{@link CIQ.PlotComplementer#resetRenderingParameters}.\n * \t\t\t\t\t<p>Here are a few examples of rendering parameters:</p>\n * ```javascript\n * //Assuming a PlotComplementer declared as \"forecaster\":\n * forecaster.renderingParameters = {chartType:\"scatterplot\", opacity:0.5, field:\"Certainty\"}\n * forecaster.renderingParameters = {chartType:\"histogram\", border_color:\"transparent\", opacity:0.3}\n * forecaster.renderingParameters = {chartType:\"channel\", opacity:0.5, pattern:\"dotted\"}\n * forecaster.renderingParameters = {chartType:\"candle\", opacity:0.5, color:\"blue\", border_color:\"blue\"}\n * ```\n * @constructor\n * @name CIQ.PlotComplementer\n * @since 7.3.0\n * @example <caption>Use for Forecasting</caption>\n\tvar forecaster = new CIQ.PlotComplementer({\n\t\t\t\t\t\t stx:stxx,\n\t\t\t\t\t\t id:\"forecast\",\n\t\t\t\t\t\t quoteFeed: fcstFeed.quoteFeedForecastSimulator,\n\t\t\t\t\t\t behavior: {refreshInterval:60},\n\t\t\t\t\t\t decorator: {symbol:\"_fcst\", display:\" Forecast\"},\n\t\t\t\t\t\t renderingParameters: {chartType:\"channel\", opacity:0.5, pattern:\"dotted\"}\n\t\t\t\t\t });\n */\nCIQ.PlotComplementer =\n\tCIQ.PlotComplementer ||\n\tfunction (params) {\n\t\tvar stx = params.stx;\n\t\tvar unique = CIQ.uniqueID();\n\t\tif (!params.decorator) params.decorator = {};\n\t\tvar symbolDecorator = params.decorator.symbol || \"_\" + unique;\n\t\tvar displayDecorator = params.decorator.display || \" (addl)\";\n\t\tif (!stx.plotComplementers) stx.plotComplementers = [];\n\t\tstx.plotComplementers.push(this);\n\n\t\tthis.id = params.id || unique;\n\n\t\tthis.defaultRenderingParameters = {\n\t\t\tchartType: \"line\",\n\t\t\twidth: 1,\n\t\t\topacity: 0.5\n\t\t};\n\n\t\tif (params.renderingParameters)\n\t\t\tthis.defaultRenderingParameters = params.renderingParameters;\n\n\t\tvar self = this;\n\t\tfunction addSeries(stx, symbol, parameters, id) {\n\t\t\tfunction verifyQuoteFeed(stx) {\n\t\t\t\tif (!stx.quoteDriver) return;\n\t\t\t\tif (!params.quoteFeed) return;\n\t\t\t\tfor (var qf = 0; qf < stx.quoteDriver.quoteFeeds.length; qf++) {\n\t\t\t\t\tif (stx.quoteDriver.quoteFeeds[qf].engine == params.quoteFeed) return;\n\t\t\t\t}\n\t\t\t\treturn \"err\";\n\t\t\t}\n\t\t\tif (verifyQuoteFeed(stx) == \"err\") return;\n\t\t\tif (!id) id = symbol;\n\t\t\tif (stx.isEquationChart(symbol)) return;\n\t\t\tif (!parameters) parameters = {};\n\t\t\tif (parameters.isComparison) return;\n\t\t\tif (id && id.indexOf(symbolDecorator) == -1) {\n\t\t\t\tvar fId = id + symbolDecorator,\n\t\t\t\t\tfSymbol = symbol + symbolDecorator;\n\t\t\t\tvar masterRenderer = stx.getRendererFromSeries(id);\n\t\t\t\tvar myParms = CIQ.extend(\n\t\t\t\t\t{\n\t\t\t\t\t\tdisplay: symbol + displayDecorator,\n\t\t\t\t\t\tname: fId,\n\t\t\t\t\t\tsymbol: fSymbol,\n\t\t\t\t\t\tsymbolObject: {\n\t\t\t\t\t\t\tsymbol: fSymbol,\n\t\t\t\t\t\t\tgenerator: self.id,\n\t\t\t\t\t\t\tmasterSymbol: symbol\n\t\t\t\t\t\t},\n\t\t\t\t\t\toverChart: false,\n\t\t\t\t\t\tgapDisplayStyle: true,\n\t\t\t\t\t\tpermanent: true,\n\t\t\t\t\t\tpanel: parameters.panel,\n\t\t\t\t\t\tyAxis: parameters.yAxis,\n\t\t\t\t\t\tshareYAxis: true,\n\t\t\t\t\t\tloadData: !!self.quoteFeed,\n\t\t\t\t\t\tdependentOf: masterRenderer\n\t\t\t\t\t\t\t? masterRenderer.params.name\n\t\t\t\t\t\t\t: stx.mainSeriesRenderer.params.name\n\t\t\t\t\t},\n\t\t\t\t\tself.renderingParameters\n\t\t\t\t);\n\t\t\t\tif (!myParms.color) myParms.color = parameters.color || \"auto\";\n\t\t\t\tstx.addSeries(fId, myParms, function (error, obj) {\n\t\t\t\t\tif (error) stx.removeSeries(fId, stx.chart);\n\t\t\t\t\tif (stx.chart.seriesRenderers[fId]) {\n\t\t\t\t\t\tstx.chart.seriesRenderers[fId].params.display = myParms.display;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tfunction removeSeries(stx, id, chart) {\n\t\t\tif (id && id.indexOf(symbolDecorator) == -1)\n\t\t\t\tstx.removeSeries(id + symbolDecorator, chart);\n\t\t}\n\n\t\tfunction symbolChange(obj) {\n\t\t\tif (obj.action == \"master\") {\n\t\t\t\tif (!obj.prevSymbol) obj.prevSymbol = obj.symbol;\n\t\t\t\tremoveSeries(obj.stx, obj.prevSymbol, obj.stx.chart);\n\t\t\t\taddSeries(obj.stx, obj.symbol);\n\t\t\t} else if (obj.action == \"add-series\") {\n\t\t\t\tremoveSeries(obj.stx, obj.id, obj.stx.chart);\n\t\t\t\taddSeries(obj.stx, obj.symbol, obj.parameters, obj.id);\n\t\t\t} else if (obj.action == \"remove-series\") {\n\t\t\t\tremoveSeries(obj.stx, obj.id, obj.stx.chart);\n\t\t\t}\n\t\t}\n\n\t\tstx.addEventListener(\"symbolChange\", symbolChange);\n\t\tstx.addEventListener(\"symbolImport\", symbolChange);\n\n\t\t/**\n\t\t * Resets the `PlotComplementer` rendering values to the default settings.\n\t\t *\n\t\t * Default settings can be provided in the parameters passed to the `PlotComplementer` constructor. If no settings are\n\t\t * provided to the constructor, `PlotComplementer` uses the following defaults: `{ chartType:\"line\", width:1, opacity:0.5 }`.\n\t\t *\n\t\t * The rendering parameters may be set anytime after creating `PlotComplementer`; for example, to set an ad-hoc rendering\n\t\t * right before adding a series.\n\t\t *\n\t\t * @alias resetRenderingParameters\n\t\t * @memberof CIQ.PlotComplementer.prototype\n\t\t * @since 7.3.0\n\t\t */\n\t\tthis.resetRenderingParameters = function () {\n\t\t\tthis.renderingParameters = this.defaultRenderingParameters;\n\t\t};\n\n\t\t/**\n\t\t * Sets a quote feed for the `PlotComplementer`.\n\t\t *\n\t\t * Automatically called when a quote feed is provided in the constructor argument. If a quote feed or `behavior` object is not\n\t\t * specified in `params`, this function returns without doing anything.\n\t\t *\n\t\t * @param {object} params.quoteFeed Quote feed to attach to the quote driver to satisfy any quote requests for any series created\n\t\t * \t\t\t\t\tby the add-on. This quote feed is like any time series quote feed object. See the\n\t\t * \t\t\t\t\t[Data Integration Overview]{@tutorial DataIntegrationOverview}.\n\t\t * @param {object} params.behavior Behavior for the quote feed supplied in this parameter list. This object is like any `behavior`\n\t\t * \t\t\t\t\tobject associated with a quote feed. See {@link CIQ.ChartEngine#attachQuoteFeed} for more information on\n\t\t * \t\t\t\t\t`behavior` objects.\n\t\t * @param {function} [params.filter] Filters the quote feed supplied in this parameter list. The filter function takes as an\n\t\t * \t\t\t\t\targument an object typically containing `symbolObject`, `symbol`, and `interval` properties. The properties\n\t\t * \t\t\t\t\tassociate the `PlotComplementer` with an instrument. If the `filter` function returns true, the\n\t\t * \t\t\t\t\t`PlotComplementer` quote feed is used for the instrument.\n\t\t * \t\t\t\t\t<p>This `filter` function is like the `filter` in basic quote feeds.\n\t\t * \t\t\t\t\tSee {@link CIQ.ChartEngine#attachQuoteFeed} for more information on quote feed `filter` functions.</p>\n\t\t * @alias setQuoteFeed\n\t\t * @memberof CIQ.PlotComplementer.prototype\n\t\t * @since 7.3.0\n\t\t */\n\t\tthis.setQuoteFeed = function (params) {\n\t\t\tif (!params.quoteFeed || !params.behavior) return;\n\t\t\tvar behavior = CIQ.clone(params.behavior);\n\t\t\tbehavior.generator = this.id;\n\t\t\tvar existingFilter = params.filter;\n\t\t\tvar filter = function (params) {\n\t\t\t\tif (existingFilter && !existingFilter(params)) return false;\n\t\t\t\treturn params.symbolObject.generator == behavior.generator;\n\t\t\t};\n\t\t\tstx.attachQuoteFeed(params.quoteFeed, behavior, filter);\n\t\t\tthis.quoteFeed = params.quoteFeed;\n\t\t};\n\n\t\tthis.setQuoteFeed(params);\n\t\tthis.resetRenderingParameters();\n\t};\n\n};\n\nlet __js_addons_rangeSlider_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\n/**\n * Add-on that puts a range slider under the chart.\n *\n * This allows the `dataSegment` to be selectable as a portion of the dataset.\n *\n * Requires *js/addOns.js* and jQuery.\n *\n * It also requires additional CSS.\n *\n * Either add:\n * ```\n * <link rel=\"stylesheet\" type=\"text/css\" href=\"css/chartiq.css\" media=\"screen\" />\n * ```\n * Or explicitly include this CSS:\n * ```\n * .stx_range_slider.shading {\n *     background-color: rgba(128, 128, 128, 0.3);\n *     border: solid 2px #0090b7;\n *     width: 5px;\n * }\n * ```\n * Once instantiated, it can be displayed or hidden by simply  setting the `rangeSlider` parameter of the primary chart's **layout object**,\n * and then issuing a layout change event to trigger the new status.\n * Make sure to use the callback to enable the slider on initial load to prevent 'out of sequence' issues.\n * See examples for exact syntax.\n *\n * Remember, a range slider is simply just another chart. So you configure it and customize it using the same parameters as you would the primary chart.\n * The only difference is that the slider object will be a sub element of the primary chart, living inside the `slider.slider` object.\n * <br>For example, if you wanted to turn off the x axis on the slider, assuming a chart instantiated as `stxx`, you would execute:\n * ```\n * stxx.slider.slider.xaxisHeight=0;\n * ```\n *\n * If using chartIQ Web Components, the slider needs to be created **before** the UI manager (startUI) is called for custom themes to apply.\n *\n * It is important to note that the range slider chart container will 'create itself' **UNDER** the primary chart container, not **INSIDE**.\n * As such, to ensure styling is shared between the two containers, so they match in look and feel, all the styling must be on a parent div container rather than the primary chart container itself.\n *\n * For example, do this:\n * ```\n * <div class=\"all-charts\">\n * <div style=\"grid-column: span 6;grid-row: span 2;\">\n *     <div class=\"chartwrap\"> <!-- begin of wrapper with desired styling -->\n *     <div class=\"chartContainer1\" style=\"width:100%;height:100%;position:relative\"></div>\n *     <!-- the slider will be added here -->\n *     </div>\n * </div> <!-- end of wrapper -->\n * </div>\n * ```\n *\n * Not this:\n * ```HTML\n * <div class=\"all-charts\">\n * <div class=\"chartwrap\" style=\"grid-column: span 6;grid-row: span 2;\">\n *     <div class=\"chartContainer1\" style=\"width:100%;height:100%;position:relative\"></div>\n * </div>\n * </div>\n * ```\n *\n * Range slider working example:\n * <iframe width=\"800\" height=\"350\" scrolling=\"no\" seamless=\"seamless\" align=\"top\" style=\"float:top\" src=\"https://jsfiddle.net/chartiq/dtug29yx/embedded/result,js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"1\"></iframe>\n *\n * @param {object} params Configuration parameters.\n * @param {CIQ.ChartEngine} [params.stx] The chart object.\n * @param {number} [params.height=95] Height of range slider panel.\n * @param {object} [params.yAxis] Optional yAxis parameters.\n * @param {number} [params.chartContainer=stxx.container] jQuery handle to the main chart\n * \t\tcontainer.\n * @param {string} [params.menuContextClass] A CSS class name used to query the menu DOM element\n * \t\tthat contains the UI control for the range slider add-on. In a multi-chart document, the\n * \t\tadd-on is available only on charts that have a menu DOM element with the value for\n * \t\t`menuContextClass` as a class attribute.\n *\n * @constructor\n * @name CIQ.RangeSlider\n * @since\n * - 4.0.0\n * - 6.1.0 Added `params.yAxis`.\n * - 8.0.0 Added `params.menuContextClass`.\n *\n * @example\n * <caption>Declare a range slider and enable by default using the loadChart callback.</caption>\n * var stxx=new CIQ.ChartEngine({container:document.querySelector(\".chartContainer\")});\n *\n * stxx.attachQuoteFeed(quoteFeedSimulator,{refreshInterval:1,bufferSize:200});\n *\n * // instantiate a range slider\n * new CIQ.RangeSlider({stx:stxx});\n *\n * function displayChart(){\n *     stxx.newChart(\"SPY\", null, null,function(){\n *         // for smoother visualization, enable AFTER THE MAIN CHART HAS COMPLETED LOADING ITS DATA.\n *         stxx.layout.rangeSlider=true; // show the slider\n *         stxx.changeOccurred(\"layout\"); // signal the change to force a redraw.\n *     }\n * });\n *\n * @example\n * <caption>Declare a range slider and enable/disable using commands to be triggered from a menu.</caption>\n * var stxx=new CIQ.ChartEngine({container:document.querySelector(\".chartContainer\")});\n *\n * // Instantiate a range slider.\n * new CIQ.RangeSlider({stx:stxx});\n *\n * // To display the slider from a menu use:\n * stxx.layout.rangeSlider=true; // show the slider\n * stxx.changeOccurred(\"layout\"); // signal the change to force a redraw.\n *\n * // To hide the slider from a menu use:\n * stxx.layout.rangeSlider=false; // hide the slider\n * stxx.changeOccurred(\"layout\"); // signal the change to force a redraw.\n */\nCIQ.RangeSlider =\n\tCIQ.RangeSlider ||\n\tfunction (params) {\n\t\tvar stx = params.stx;\n\t\tstx.slider = this;\n\t\tvar sliderHeight = params.height ? params.height : 95;\n\t\tvar chartContainer = params.chartContainer\n\t\t\t? $(params.chartContainer)\n\t\t\t: $(params.stx.container);\n\n\t\tvar ciqSlider = $('<div class=\"ciq-chart\"></div>');\n\t\tvar sliderContainer = $('<div class=\"chartContainer\"></div>');\n\t\tciqSlider.insertAfter(chartContainer.parent()).append(sliderContainer);\n\t\tciqSlider\n\t\t\t.css(\"height\", sliderHeight + \"px\")\n\t\t\t.css(\"padding-top\", \"5px\")\n\t\t\t.hide();\n\t\tsliderContainer.css(\"height\", \"100%\");\n\t\tsliderContainer.prop(\"dimensionlessCanvas\", true);\n\t\tvar self = (this.slider = new CIQ.ChartEngine({\n\t\t\tcontainer: sliderContainer[0],\n\t\t\tpreferences: { labels: false, whitespace: 0 }\n\t\t}));\n\t\tself.xaxisHeight = 30;\n\t\tself.manageTouchAndMouse = false;\n\t\tself.minimumCandleWidth = 0;\n\t\tself.container.style.cursor = \"ew-resize\";\n\t\tvar yAxis = self.chart.panel.yAxis;\n\t\tyAxis.drawCurrentPriceLabel = false;\n\t\tObject.defineProperty(yAxis, \"position\", {\n\t\t\tget: function () {\n\t\t\t\treturn stx.slider.yAxisPosition || stx.chart.panel.yAxis.position;\n\t\t\t},\n\t\t\tset: function (position) {\n\t\t\t\tstx.slider.yAxisPosition = position;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(yAxis, \"width\", {\n\t\t\tget: function () {\n\t\t\t\tif (stx.slider.yAxisWidth === 0) return 0;\n\t\t\t\treturn stx.slider.yAxisWidth || stx.chart.panel.yAxis.width;\n\t\t\t},\n\t\t\tset: function (width) {\n\t\t\t\tstx.slider.yAxisWidth = width;\n\t\t\t}\n\t\t});\n\t\tCIQ.extend(yAxis, params.yAxis);\n\t\tself.chart.baseline.userLevel = false;\n\t\tif (self.controls.home) self.controls.home.style.width = 0;\n\t\tself.initializeChart();\n\t\tvar subholder = self.chart.panel.subholder;\n\n\t\tconst menuClass = `${\n\t\t\t(params.menuContextClass && \".\" + params.menuContextClass) || \"body\"\n\t\t} .rangeslider-ui`;\n\t\tCIQ.addInternalStylesheet(`${menuClass} { display: inherit }`, menuClass);\n\n\t\t/**\n\t\t * Dynamically updates the styling of the range slider.\n\t\t *\n\t\t * This method can be used to update CSS styles if you are injecting stylesheets using\n\t\t * JavaScript.\n\t\t *\n\t\t * @param {string} obj The CSS selector for which a style property is changed.\n\t\t * @param {string} attribute The style property changed in the CSS selector rule-set.\n\t\t * @param {string} value The value to apply to the CSS property.\n\t\t *\n\t\t * @alias updateStyles\n\t\t * @memberof CIQ.RangeSlider.prototype\n\t\t * @since 8.0.0\n\t\t *\n\t\t * @example\n\t\t * // Set the shading of the range slider.\n\t\t * stxx.slider.updateStyles(\n\t\t *     'stx_range_slider shading',\n\t\t *     'backgroundColor',\n\t\t *     'rgba(200, 50, 50, 0.45)'\n\t\t * );\n\t\t *\n\t\t * @example\n\t\t * // Set the color of the bars of the range slider to red.\n\t\t * stxx.slider.updateStyles(\n\t\t *     'stx_range_slider shading',\n\t\t *     'borderTopColor',\n\t\t *     'rgba(255, 0, 0)'\n\t\t * );\n\t\t */\n\t\tthis.updateStyles = function (obj, attribute, value) {\n\t\t\tstx.setStyle(obj, attribute, value);\n\t\t\tthis.style = stx.canvasStyle(\"stx_range_slider shading\");\n\t\t};\n\n\t\tthis.display = function (on) {\n\t\t\tif (stx.layout.rangeSlider !== on) {\n\t\t\t\t// do this the way it was intended\n\t\t\t\tstx.layout.rangeSlider = on;\n\t\t\t\tstx.changeOccurred(\"layout\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tciqSlider[on ? \"show\" : \"hide\"]();\n\t\t\tstx.resizeChart();\n\t\t\t$(window).resize();\n\t\t\tif (!on) return;\n\t\t\tself.resizeChart();\n\t\t\tself.initializeChart();\n\t\t\tself.draw();\n\t\t\tthis.drawSlider();\n\t\t};\n\t\tthis.setSymbol = function (symbol) {\n\t\t\tself.chart.panel.display = self.chart.symbol = symbol;\n\t\t\tself.setMainSeriesRenderer();\n\t\t\tself.resizeChart();\n\t\t\tthis.adjustRange(stx.chart);\n\t\t\tself.draw();\n\t\t\tthis.drawSlider();\n\t\t};\n\t\tthis.acceptLayoutChange = function (layout) {\n\t\t\tvar doDraw = false;\n\t\t\tif (self.layout.rangeSlider !== layout.rangeSlider) {\n\t\t\t\tstx.slider.display(layout.rangeSlider);\n\t\t\t}\n\t\t\tvar relevantLayoutPropertiesForRedraw = [\n\t\t\t\t\"chartType\",\n\t\t\t\t\"aggregationType\",\n\t\t\t\t\"periodicity\",\n\t\t\t\t\"interval\",\n\t\t\t\t\"timeUnit\",\n\t\t\t\t\"chartScale\",\n\t\t\t\t\"rangeSlider\",\n\t\t\t\t\"flipped\",\n\t\t\t\t\"extended\",\n\t\t\t\t\"marketSessions\",\n\t\t\t\t\"kagi\",\n\t\t\t\t\"rangebars\",\n\t\t\t\t\"renko\",\n\t\t\t\t\"priceLines\",\n\t\t\t\t\"pandf\"\n\t\t\t];\n\t\t\trelevantLayoutPropertiesForRedraw.forEach(function (x) {\n\t\t\t\tif (!CIQ.equals(self.layout[x], layout[x])) {\n\t\t\t\t\tself.layout[x] = layout[x];\n\t\t\t\t\tdoDraw = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!ciqSlider.is(\":visible\")) return;\n\t\t\tif (doDraw) {\n\t\t\t\tself.setMainSeriesRenderer();\n\t\t\t\tself.draw();\n\t\t\t\tthis.drawSlider();\n\t\t\t}\n\t\t};\n\t\tthis.adjustRange = function (chart) {\n\t\t\tif (!chart.dataSet) return;\n\t\t\tvar myChart = self.chart;\n\t\t\tif (!myChart.width) return;\n\t\t\tvar scrollOffset = 0,\n\t\t\t\tticksOffset = 0;\n\t\t\tif (stx.quoteDriver) {\n\t\t\t\tvar behaviorParams = {\n\t\t\t\t\tsymbol: chart.symbol,\n\t\t\t\t\tsymbolObject: chart.symbolObject,\n\t\t\t\t\tinterval: stx.layout.interval\n\t\t\t\t};\n\t\t\t\tif (\n\t\t\t\t\t(behaviorParams.interval == \"month\" ||\n\t\t\t\t\t\tbehaviorParams.interval == \"week\") &&\n\t\t\t\t\t!stx.dontRoll\n\t\t\t\t) {\n\t\t\t\t\tbehaviorParams.interval = \"day\";\n\t\t\t\t}\n\t\t\t\tvar behavior = stx.quoteDriver.getQuoteFeed(behaviorParams).behavior;\n\t\t\t\tif (behavior && behavior.bufferSize) {\n\t\t\t\t\tif (chart.moreAvailable) scrollOffset = behavior.bufferSize;\n\t\t\t\t\tif (stx.isHistoricalMode()) ticksOffset = behavior.bufferSize;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmyChart.baseline.defaultLevel = chart.baseline.actualLevel;\n\t\t\tmyChart.scroll =\n\t\t\t\tMath.max(\n\t\t\t\t\t0,\n\t\t\t\t\tchart.dataSet.length -\n\t\t\t\t\t\tstx.tickFromDate(chart.endPoints.begin) -\n\t\t\t\t\t\tscrollOffset\n\t\t\t\t) + 1;\n\t\t\tmyChart.maxTicks = myChart.scroll - ticksOffset + 1;\n\t\t\tself.layout.candleWidth = myChart.width / myChart.maxTicks;\n\t\t};\n\t\tthis.copyData = function (chart) {\n\t\t\tif (!chart.dataSet) return;\n\t\t\tvar myChart = self.chart;\n\t\t\tmyChart.masterData = self.masterData = chart.masterData;\n\t\t\tmyChart.dataSet = chart.dataSet;\n\t\t\tmyChart.state = chart.state;\n\t\t\tself.draw();\n\t\t\tthis.drawSlider();\n\t\t};\n\t\tthis.calculateYAxisPosition = function () {\n\t\t\tvar panel = self.chart.panel;\n\t\t\tvar currentPosition = self.getYAxisCurrentPosition(panel.yAxis, panel);\n\t\t\tif (currentPosition != panel.yAxis.position)\n\t\t\t\tself.calculateYAxisPositions();\n\t\t};\n\t\tthis.drawSlider = function () {\n\t\t\tif (!ciqSlider.is(\":visible\")) return;\n\t\t\tif (!stx.chart.dataSet || !stx.chart.dataSet.length) return;\n\t\t\tvar style = this.style;\n\t\t\tif (!style)\n\t\t\t\tstyle = this.style = stx.canvasStyle(\"stx_range_slider shading\");\n\t\t\tvar chartPanel = stx.chart.panel,\n\t\t\t\tctx = self.chart.context,\n\t\t\t\tsegmentImage = self.chart.segmentImage || [],\n\t\t\t\thalfCandle = self.layout.candleWidth / 2;\n\t\t\tvar left = (self.tickLeft = Math.max(\n\t\t\t\tstx.tickFromPixel(chartPanel.left + halfCandle),\n\t\t\t\t0\n\t\t\t));\n\t\t\tvar right = (self.tickRight = Math.min(\n\t\t\t\tstx.tickFromPixel(chartPanel.right - halfCandle),\n\t\t\t\tstx.chart.dataSet.length - 1\n\t\t\t));\n\t\t\tvar pLeft = (self.pixelLeft =\n\t\t\t\tself.pixelFromTick(left) -\n\t\t\t\t(segmentImage[left] ? segmentImage[left].candleWidth / 2 : halfCandle));\n\t\t\tvar pRight = (self.pixelRight =\n\t\t\t\tself.pixelFromTick(right) +\n\t\t\t\t(segmentImage[right]\n\t\t\t\t\t? segmentImage[right].candleWidth / 2\n\t\t\t\t\t: halfCandle));\n\t\t\tvar leftBoundary = subholder.offsetLeft,\n\t\t\t\trightBoundary = leftBoundary + subholder.offsetWidth;\n\t\t\tctx.save();\n\t\t\tctx.beginPath();\n\t\t\tctx.fillStyle = style.backgroundColor;\n\t\t\tctx.fillRect(\n\t\t\t\tleftBoundary,\n\t\t\t\tsubholder.offsetTop,\n\t\t\t\tpLeft - leftBoundary,\n\t\t\t\tsubholder.offsetHeight\n\t\t\t);\n\t\t\tctx.fillRect(\n\t\t\t\trightBoundary,\n\t\t\t\tsubholder.offsetTop,\n\t\t\t\tpRight - rightBoundary,\n\t\t\t\tsubholder.offsetHeight\n\t\t\t);\n\t\t\tctx.strokeStyle = style.borderTopColor;\n\t\t\tctx.lineWidth = parseInt(style.borderWidth, 10);\n\t\t\tctx.moveTo(pLeft, subholder.offsetTop);\n\t\t\tctx.lineTo(pLeft, subholder.offsetTop + subholder.offsetHeight);\n\t\t\tctx.moveTo(pRight, subholder.offsetTop);\n\t\t\tctx.lineTo(pRight, subholder.offsetTop + subholder.offsetHeight);\n\t\t\tctx.stroke();\n\t\t\tctx.beginPath();\n\t\t\tctx.lineWidth = parseInt(style.width, 10);\n\t\t\tctx.lineCap = \"round\";\n\t\t\tctx.moveTo(pLeft, subholder.offsetTop + subholder.offsetHeight / 4);\n\t\t\tctx.lineTo(pLeft, subholder.offsetTop + (3 * subholder.offsetHeight) / 4);\n\t\t\tctx.moveTo(pRight, subholder.offsetTop + subholder.offsetHeight / 4);\n\t\t\tctx.lineTo(\n\t\t\t\tpRight,\n\t\t\t\tsubholder.offsetTop + (3 * subholder.offsetHeight) / 4\n\t\t\t);\n\t\t\tctx.stroke();\n\t\t\tctx.restore();\n\t\t};\n\t\tstx.addEventListener(\"layout\", function (obj) {\n\t\t\tobj.stx.slider.acceptLayoutChange(obj.stx.layout);\n\t\t});\n\t\tstx.addEventListener(\"preferences\", function (obj) {\n\t\t\tvar language = obj.stx.preferences.language;\n\t\t\tif (CIQ.I18N && self.preferences.language != language) {\n\t\t\t\tCIQ.I18N.localize(self, language);\n\t\t\t}\n\t\t\tself.preferences.language = language;\n\t\t\tself.draw();\n\t\t});\n\t\tstx.addEventListener(\"symbolChange\", function (obj) {\n\t\t\tif (obj.action == \"master\") obj.stx.slider.setSymbol(obj.symbol);\n\t\t});\n\t\tstx.addEventListener(\"symbolImport\", function (obj) {\n\t\t\tif (obj.action == \"master\") obj.stx.slider.setSymbol(obj.symbol);\n\t\t\tobj.stx.slider.acceptLayoutChange(obj.stx.layout);\n\t\t});\n\t\tstx.addEventListener(\"theme\", function (obj) {\n\t\t\tself.clearPixelCache();\n\t\t\tself.styles = {};\n\t\t\tself.chart.container.style.backgroundColor = \"\";\n\t\t\tif (CIQ.ThemeHelper) {\n\t\t\t\tvar helper = new CIQ.ThemeHelper({ stx: obj.stx });\n\t\t\t\thelper.params.stx = self;\n\t\t\t\thelper.update();\n\t\t\t}\n\t\t});\n\t\tstx.append(\"createDataSet\", function () {\n\t\t\tthis.slider.adjustRange(this.chart);\n\t\t\tthis.slider.copyData(this.chart);\n\t\t});\n\t\tstx.append(\"draw\", function () {\n\t\t\tif (!ciqSlider.is(\":visible\")) return;\n\t\t\tif (!self.chart.dataSet) return;\n\t\t\tthis.slider.adjustRange(this.chart);\n\t\t\tthis.slider.calculateYAxisPosition();\n\t\t\tself.draw();\n\t\t\tthis.slider.drawSlider();\n\t\t});\n\t\tstx.prepend(\"resizeChart\", function () {\n\t\t\tvar ciqChart = chartContainer.parent(),\n\t\t\t\tchartArea = ciqChart.parent();\n\t\t\tvar heightOffset = ciqChart.height() - chartContainer.height();\n\t\t\tvar totalHeightOfContainers = chartArea.height();\n\t\t\tchartArea.find(\".chartContainer\").each(function () {\n\t\t\t\tif (this !== chartContainer[0] && $(this).is(\":visible\"))\n\t\t\t\t\ttotalHeightOfContainers -= $(this).parent().outerHeight(true);\n\t\t\t});\n\t\t\tciqChart.height(totalHeightOfContainers);\n\t\t\tif (this.layout.rangeSlider) {\n\t\t\t\tciqSlider.show();\n\t\t\t\tself.resizeChart();\n\t\t\t\tself.initializeChart();\n\t\t\t\tself.draw();\n\t\t\t\tthis.slider.drawSlider();\n\t\t\t} else {\n\t\t\t\tciqSlider.hide();\n\t\t\t}\n\t\t});\n\t\t$(subholder).on(\"mousedown touchstart pointerdown\", function (e) {\n\t\t\tvar start = e.offsetX;\n\t\t\tif (!start && start !== 0) start = e.originalEvent.layerX;\n\t\t\tif (!start && start !== 0) return; // wrong event\n\t\t\tvar s = $(self);\n\t\t\ts.prop(\"startDrag\", start)\n\t\t\t\t.prop(\"startPixelLeft\", self.pixelLeft)\n\t\t\t\t.prop(\"startPixelRight\", self.pixelRight);\n\t\t\tvar style = stx.slider.style;\n\t\t\tif (!style)\n\t\t\t\tstyle = stx.slider.style = stx.canvasStyle(\"stx_range_slider shading\");\n\t\t\tvar bw = parseInt(style.borderLeftWidth, 10);\n\t\t\tstart += this.offsetLeft;\n\t\t\tif (start < self.pixelRight - bw) s.prop(\"needsLeft\", true);\n\t\t\tif (start > self.pixelLeft + bw) s.prop(\"needsRight\", true);\n\t\t\tif (CIQ.touchDevice) return;\n\t\t\te.target.classList.add(\"stx-drag-chart\");\n\t\t});\n\t\t$(subholder).on(\"mouseup mouseout touchend pointerup\", function (e) {\n\t\t\te.target.classList.remove(\"stx-drag-chart\");\n\t\t\tvar s = $(self);\n\t\t\tself.container.style.cursor = \"ew-resize\";\n\t\t\ts.prop(\"startDrag\", null)\n\t\t\t\t.prop(\"needsLeft\", false)\n\t\t\t\t.prop(\"needsRight\", false);\n\t\t});\n\t\t$(subholder).on(\"mousemove touchmove pointermove\", function (e) {\n\t\t\tvar s = $(self);\n\t\t\tvar startDrag = s.prop(\"startDrag\");\n\t\t\tif (!startDrag && startDrag !== 0) return;\n\t\t\tvar touches = e.originalEvent.touches;\n\t\t\tvar movement =\n\t\t\t\ttouches && touches.length\n\t\t\t\t\t? self.backOutX(touches[0].pageX) - e.target.offsetLeft\n\t\t\t\t\t: e.offsetX;\n\t\t\tif (!movement && movement !== 0) return; // wrong event\n\t\t\tself.container.style.cursor = \"grab\";\n\t\t\tmovement -= startDrag;\n\t\t\tvar tickLeft = self.tickLeft,\n\t\t\t\ttickRight = self.tickRight;\n\t\t\tvar startPixelLeft = s.prop(\"startPixelLeft\"),\n\t\t\t\tstartPixelRight = s.prop(\"startPixelRight\");\n\t\t\tvar needsLeft = s.prop(\"needsLeft\"),\n\t\t\t\tneedsRight = s.prop(\"needsRight\");\n\t\t\tif (needsLeft) {\n\t\t\t\tif (startPixelLeft + movement < self.chart.left)\n\t\t\t\t\tmovement = self.chart.left - startPixelLeft;\n\t\t\t\tif (needsRight && startPixelRight + movement >= self.chart.right) {\n\t\t\t\t\tmovement = self.chart.right - startPixelRight;\n\t\t\t\t\tif (!self.isHome()) movement += self.layout.candleWidth / 2; // force a right scroll\n\t\t\t\t}\n\t\t\t\ttickLeft = self.tickFromPixel(startPixelLeft + movement);\n\t\t\t\tif (needsRight) tickRight = tickLeft + self.tickRight - self.tickLeft;\n\t\t\t} else if (needsRight) {\n\t\t\t\ttickRight = Math.min(\n\t\t\t\t\tself.tickFromPixel(startPixelRight + movement),\n\t\t\t\t\tstx.chart.dataSet.length - 1\n\t\t\t\t);\n\t\t\t} else return;\n\n\t\t\tvar newCandleWidth = stx.chart.width / (tickRight - tickLeft + 1);\n\t\t\tif (tickRight >= tickLeft && newCandleWidth >= stx.minimumCandleWidth) {\n\t\t\t\tself.tickLeft = tickLeft;\n\t\t\t\tself.tickRight = tickRight;\n\t\t\t\tstx.chart.scroll = stx.chart.dataSet.length - tickLeft;\n\t\t\t\tif (!needsLeft || !needsRight) {\n\t\t\t\t\tstx.setCandleWidth(newCandleWidth);\n\t\t\t\t}\n\t\t\t\tstx.micropixels = 0;\n\t\t\t\tstx.draw();\n\t\t\t}\n\t\t});\n\t\tthis.adjustRange(stx.chart);\n\t\tthis.copyData(stx.chart);\n\t};\n\n};\n\nlet __js_addons_tooltip_ = (_exports) => {\n\n/* global _CIQ, _timezoneJS, _SplinePlotter */\n\n\nvar CIQ = typeof _CIQ !== \"undefined\" ? _CIQ : _exports.CIQ;\n\nif (!CIQ.Marker) {\n\tconsole.error(\"tooltip addon requires first activating markers feature.\");\n} else {\n\t/**\n\t * Add-On that creates a hovering \"tooltip\" as mouse is moved over the chart when the cross-hairs are active.\n\t *\n\t * Tooltip Example <iframe width=\"800\" height=\"500\" scrolling=\"no\" seamless=\"seamless\" align=\"top\" style=\"float:top\" src=\"https://jsfiddle.net/chartiq/5kux6j8p/embedded/result,js,html/\" allowfullscreen=\"allowfullscreen\" frameborder=\"1\"></iframe>\n\t *\n\t * The tool-tip is directly linked to the cross-hairs. So if you disable the cross hairs, the tool-tip also goes away.\n\t *\n\t * To toggle cross-hairs use <a href=\"CIQ.ChartEngine.html#layout%5B%60crosshair%60%5D\">CIQ.ChartEngine.layout.crosshair</a>. Set to `true` or `false` as needed.\n\t *\n\t * Requires `jquery` and `addOns.js`; as well as `markers.js` or the bundle `standard.js`.\n\t *\n\t * There can be only one CIQ.Tooltip per chart.\n\t *\n\t * Color and layout can be customized via `stx-hu-tooltip` and related CSS classes. Defaults can be found in `stx-chart.css`.\n\t *\n\t * CIQ.Tooltip automatically creates its own HTML inside the chart container.\n\t * Here is an example of the structure (there will be one field tag per displayed element):\n\t * ```\n\t * <stx-hu-tooltip>\n\t * \t\t<stx-hu-tooltip-field>\n\t * \t\t\t<stx-hu-tooltip-field-name></stx-hu-tooltip-field-name>\n\t * \t\t\t<stx-hu-tooltip-field-value></stx-hu-tooltip-field-value>\n\t * \t\t</stx-hu-tooltip-field>\n\t * </stx-hu-tooltip>\n\t * ```\n\t * By default, the `stx-hu-tooltip-field` elements are inserted in the following order:\n\t * - DT\n\t * - Open\n\t * - High\n\t * - Low\n\t * - Close\n\t * - Volume\n\t * - series\n\t * - studies\n\t *\n\t * But the default layout can be changed. You can override the order of fields or change the labels by manually inserting\n\t * the HTML that the tooltip would otherwise have created for that field.\n\t * If no override HTML is found for a particular field, the default will be used.\n\t * This HTML must be placed *inside the chart container*.\n\t *\n\t * All of the code is provided in `addOns.js` and can be fully customized by copying the source code from the library and overriding\n\t * the functions with your changes. Be sure to never modify a library file as this will hinder upgrades.\n\t *\n\t * For example, concatenating the field name ( ie: 'Jaw' ) with the study name ( ie: 'Alligator' ) is the default behavior of the tooltip for displaying the value title.\n\t * Feel free to override this behavior by creating your own custom version of the renderFunction() for the CIQ.Tooltip.\n\t * To do this, copy the entire CIQ.Tooltip code (found in addOns.js) and make the changes to your custom version. Load your custom version instead.\n\t * Specifically, look for the following code in renderFunction() that pushes out the text for each study field:\n\t * ```\n\t * $(\"<stx-hu-tooltip-field auto></stx-hu-tooltip-field>\")\n\t * .append($(\"<stx-hu-tooltip-field-name>\"+this.translateIf(fieldName)+\"</stx-hu-tooltip-field-name>\"))\n\t * .append($(\"<stx-hu-tooltip-field-value>\"+fieldValue+\"</stx-hu-tooltip-field-value>\"))\n\t * .appendTo(node);\n\t * ```\n\t * Replace `fieldName` with anything you want to use as the field title and push that instead.\n\t *\n\t * Visual Reference:<br>\n\t * ![stx-hu-tooltip](stx-hu-tooltip.png \"stx-hu-tooltip\")\n\t *\n\t * @param {object} tooltipParams The constructor parameters.\n\t * @param {CIQ.ChartEngine} [tooltipParams.stx] The chart object.\n\t * @param {boolean} [tooltipParams.ohl] set to true to show OHL data (Close is always shown).\n\t * @param {boolean} [tooltipParams.volume] set to true to show Volume.\n\t * @param {boolean} [tooltipParams.series] set to true to show value of series.\n\t * @param {boolean} [tooltipParams.studies] set to true to show value of studies.\n\t * @param {boolean} [tooltipParams.showOverBarOnly] set to true to show tooltip only when over the primary line/bars.\n\t * @param {boolean} [tooltipParams.change] set to true to show the change in daily value when isDailyInterval\n\t * @param {boolean} [tooltipParams.interpolation] set to true to show the estimated value when there is no data between bars. **Note** that a value of `null` is not considered missing data.\n\t * @param {boolean} [tooltipParams.useDataZone] set to true to show the date in the dataZone, false to use the displayZone\n\t * @constructor\n\t * @name  CIQ.Tooltip\n\t * @example <caption>Adding a hover tool tip to a chart:</caption>\n\t *\n\t * //First declare your chart engine\n\t * var stxx=new CIQ.ChartEngine({container:document.querySelector(\".chartContainer\")[0]});\n\t *\n\t * //Then link the tooltip to that chart.\n\t * //Note how we've enabled OHL, Volume, Series and Studies.\n\t * new CIQ.Tooltip({stx:stxx, ohl:true, volume:true, series:true, studies:true});\n\t *\n\t * @example <caption>Customize the order, layout or text in tooltip labels:</caption>\n\t * // In this example, we've rearranged the HTML to display the Close field first, then the DT\n\t * // We are also labeling the DT 'Date/Time' and the Close 'Last'\n\t * // The rest of the fields will be then displayed in their default order.\n\t *\n\t  \t<stx-hu-tooltip>\n\t\t\t<stx-hu-tooltip-field field=\"Close\">\n\t\t\t\t<stx-hu-tooltip-field-name>Last</stx-hu-tooltip-field-name>\n\t\t\t\t<stx-hu-tooltip-field-value></stx-hu-tooltip-field-value>\n\t\t\t</stx-hu-tooltip-field>\n\t\t\t<stx-hu-tooltip-field field=\"DT\">\n\t\t\t\t<stx-hu-tooltip-field-name>Date/Time</stx-hu-tooltip-field-name>\n\t\t\t\t<stx-hu-tooltip-field-value></stx-hu-tooltip-field-value>\n\t\t\t</stx-hu-tooltip-field>\n\t\t</stx-hu-tooltip>\n\t *\n\t * @example\n\t * // Sample CSS for the hover tool tip. Working sample found in stx-chart.css\n\t\tstx-hu-tooltip {\n\t\t\tposition: absolute;\n\t\t\tleft: -50000px;\n\t\t\tz-index: 30;\n\t\t\twhite-space: nowrap;\n\t\t\tpadding: 6px;\n\t\t\tborder: 1px solid gray;\n\t\t\tbackground-color: rgba(42,81,208,.5);\n\t\t\tcolor: white;\n\t\t}\n\n\t\tstx-hu-tooltip-field {\n\t\t\tdisplay:table-row;\n\t\t}\n\n\t\tstx-hu-tooltip-field-name {\n\t\t\tdisplay:table-cell;\n\t\t\tfont-weight:bold;\n\t\t\tpadding-right:5px;\n\t\t}\n\n\t\tstx-hu-tooltip-field-name:after {\n\t\t\tcontent:':';\n\t\t}\n\n\t\tstx-hu-tooltip-field-value {\n\t\t\tdisplay:table-cell;\n\t\t\ttext-align:right;\n\t\t}\n\t * @since\n\t * - 09-2016-19\n\t * - 5.0.0 Now `tooltipParams.showOverBarOnly` available to show tooltip only when over the primary line/bars.\n\t * - 5.1.1 [tooltipParams.change] set to true to show the change in daily value when displaying a daily interval.\n\t * - 6.2.5 New interpolation flag to show estimated value for missing series data points.\n\t * - 7.0.0 New useDataZone flag to show the DT in either the dataZone or displayZone date/time.\n\t */\n\n\tCIQ.Tooltip =\n\t\tCIQ.Tooltip ||\n\t\tfunction (tooltipParams) {\n\t\t\tif (!CIQ.Marker) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t\"CIQ.Tooltip addon requires CIQ.Marker module to be enabled.\"\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar stx = tooltipParams.stx;\n\t\t\tvar showOhl = tooltipParams.ohl;\n\t\t\tvar showChange = tooltipParams.change;\n\t\t\tvar showVolume = tooltipParams.volume;\n\t\t\tvar showSeries = tooltipParams.series;\n\t\t\tvar showStudies = tooltipParams.studies;\n\t\t\tvar showOverBarOnly = tooltipParams.showOverBarOnly;\n\t\t\tvar showInterpolation = tooltipParams.interpolation;\n\t\t\tvar useDataZone = tooltipParams.useDataZone;\n\n\t\t\tvar node = $(stx.chart.container).find(\"stx-hu-tooltip\")[0];\n\t\t\tif (!node) {\n\t\t\t\tnode = $(\"<stx-hu-tooltip></stx-hu-tooltip>\").appendTo(\n\t\t\t\t\t$(stx.chart.container)\n\t\t\t\t)[0];\n\t\t\t}\n\t\t\tCIQ.Marker.Tooltip = function (params) {\n\t\t\t\tif (!this.className) this.className = \"CIQ.Marker.Tooltip\";\n\t\t\t\tparams.label = \"tooltip\";\n\t\t\t\tCIQ.Marker.call(this, params);\n\t\t\t};\n\n\t\t\tCIQ.inheritsFrom(CIQ.Marker.Tooltip, CIQ.Marker, false);\n\n\t\t\tCIQ.Marker.Tooltip.sameBar = function (bar1, bar2) {\n\t\t\t\tif (!bar1 || !bar2) return false;\n\t\t\t\tif (+bar1.DT != +bar2.DT) return false;\n\t\t\t\tif (bar1.Close != bar2.Close) return false;\n\t\t\t\tif (bar1.Open != bar2.Open) return false;\n\t\t\t\tif (bar1.Volume != bar2.Volume) return false;\n\t\t\t\treturn true;\n\t\t\t};\n\n\t\t\tCIQ.Marker.Tooltip.placementFunction = function (params) {\n\t\t\t\tvar offset = 30;\n\t\t\t\tvar stx = params.stx;\n\t\t\t\tfor (var i = 0; i < params.arr.length; i++) {\n\t\t\t\t\tvar marker = params.arr[i];\n\t\t\t\t\tvar bar = stx.barFromPixel(stx.cx);\n\t\t\t\t\tvar quote = stx.chart.dataSegment[bar];\n\t\t\t\t\tvar goodBar;\n\t\t\t\t\tvar overBar = true;\n\t\t\t\t\tvar highPx, lowPx;\n\n\t\t\t\t\tif (quote != \"undefined\" && quote && quote.DT) {\n\t\t\t\t\t\tgoodBar = true;\n\t\t\t\t\t\tif (quote.High) highPx = stx.pixelFromPrice(quote.High);\n\t\t\t\t\t\tif (quote.Low) lowPx = stx.pixelFromPrice(quote.Low);\n\t\t\t\t\t\tif (!stx.chart.highLowBars) {\n\t\t\t\t\t\t\tif (quote.Close) {\n\t\t\t\t\t\t\t\thighPx = stx.pixelFromPrice(quote.Close) - 15;\n\t\t\t\t\t\t\t\tlowPx = stx.pixelFromPrice(quote.Close) + 15;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (showOverBarOnly && !(stx.cy >= highPx && stx.cy <= lowPx))\n\t\t\t\t\t\t\toverBar = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t//\t(stx.controls.crossX && stx.controls.crossX.style.display==\"none\") ||\n\t\t\t\t\t\t//\t(stx.controls.crossY && stx.controls.crossY.style.display==\"none\") ||\n\t\t\t\t\t\t!(\n\t\t\t\t\t\t\tstx.insideChart &&\n\t\t\t\t\t\t\tstx.layout.crosshair &&\n\t\t\t\t\t\t\tstx.displayCrosshairs &&\n\t\t\t\t\t\t\t//\t\t!stx.overXAxis &&\n\t\t\t\t\t\t\t//\t\t!stx.overYAxis &&\n\t\t\t\t\t\t\t!stx.openDialog &&\n\t\t\t\t\t\t\t!stx.activeDrawing &&\n\t\t\t\t\t\t\t!stx.grabbingScreen &&\n\t\t\t\t\t\t\tgoodBar &&\n\t\t\t\t\t\t\toverBar\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmarker.node.style.left = \"-50000px\";\n\t\t\t\t\t\tmarker.node.style.right = \"auto\";\n\t\t\t\t\t\tmarker.lastBar = {};\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tCIQ.Marker.Tooltip.sameBar(\n\t\t\t\t\t\t\tstx.chart.dataSegment[bar],\n\t\t\t\t\t\t\tmarker.lastBar\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tbar != stx.chart.dataSegment.length - 1\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tmarker.lastBar = stx.chart.dataSegment[bar];\n\t\t\t\t\tvar cw = marker.lastBar.candleWidth || stx.layout.candleWidth;\n\t\t\t\t\tif (\n\t\t\t\t\t\tparseInt(getComputedStyle(marker.node).width, 10) +\n\t\t\t\t\t\t\tstx.chart.panel.left +\n\t\t\t\t\t\t\toffset +\n\t\t\t\t\t\t\tcw <\n\t\t\t\t\t\tstx.backOutX(CIQ.ChartEngine.crosshairX)\n\t\t\t\t\t) {\n\t\t\t\t\t\tmarker.node.style.left = \"auto\";\n\t\t\t\t\t\tmarker.node.style.right =\n\t\t\t\t\t\t\tMath.round(\n\t\t\t\t\t\t\t\tstx.container.clientWidth - stx.pixelFromBar(bar) + offset\n\t\t\t\t\t\t\t) + \"px\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmarker.node.style.left =\n\t\t\t\t\t\t\tMath.round(stx.pixelFromBar(bar) + offset) + \"px\";\n\t\t\t\t\t\tmarker.node.style.right = \"auto\";\n\t\t\t\t\t}\n\t\t\t\t\tvar height = parseInt(getComputedStyle(marker.node).height, 10);\n\t\t\t\t\tvar top = Math.round(\n\t\t\t\t\t\tCIQ.ChartEngine.crosshairY - stx.top - height / 2\n\t\t\t\t\t);\n\t\t\t\t\tif (top + height > stx.height) top = stx.height - height;\n\t\t\t\t\tif (top < 0) top = 0;\n\t\t\t\t\tmarker.node.style.top = top + \"px\";\n\t\t\t\t}\n\t\t\t\t// temporarily disable overXAxis, overYAxis so the crosshairs don't hide if touch device and over Y axis (this can happen\n\t\t\t\t// due to the offset which we apply)\n\t\t\t\tvar overXAxis = stx.overXAxis,\n\t\t\t\t\toverYAxis = stx.overYAxis;\n\t\t\t\tstx.overXAxis = stx.overYAxis = false;\n\t\t\t\tstx.doDisplayCrosshairs();\n\t\t\t\tstx.overXAxis = overXAxis;\n\t\t\t\tstx.overYAxis = overYAxis;\n\t\t\t};\n\n\t\t\tfunction renderFunction() {\n\t\t\t\t// the tooltip has not been initialized with this chart.\n\t\t\t\tif (!this.huTooltip) return;\n\n\t\t\t\t// crosshairs are not on\n\t\t\t\tif (\n\t\t\t\t\t(stx.controls.crossX &&\n\t\t\t\t\t\tstx.controls.crossX.style.display == \"none\") ||\n\t\t\t\t\t(stx.controls.crossY && stx.controls.crossY.style.display == \"none\")\n\t\t\t\t)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar bar = this.barFromPixel(this.cx),\n\t\t\t\t\tdata = this.chart.dataSegment[bar];\n\t\t\t\tif (!data) {\n\t\t\t\t\tthis.positionMarkers();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tCIQ.Marker.Tooltip.sameBar(data, this.huTooltip.lastBar) &&\n\t\t\t\t\tbar != this.chart.dataSegment.length - 1\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\tvar node = $(this.huTooltip.node);\n\t\t\t\tnode.find(\"[auto]\").remove();\n\t\t\t\tnode.find(\"stx-hu-tooltip-field-value\").html();\n\n\t\t\t\tvar panel = this.chart.panel;\n\t\t\t\tvar yAxis = panel.yAxis;\n\t\t\t\tvar dupMap = {};\n\t\t\t\tvar fields = [];\n\t\t\t\tfields.push({\n\t\t\t\t\tmember: \"DT\",\n\t\t\t\t\tdisplay: \"DT\",\n\t\t\t\t\tpanel: panel,\n\t\t\t\t\tyAxis: yAxis\n\t\t\t\t});\n\t\t\t\tfields.push({\n\t\t\t\t\tmember: \"Close\",\n\t\t\t\t\tdisplay: \"Close\",\n\t\t\t\t\tpanel: panel,\n\t\t\t\t\tyAxis: yAxis\n\t\t\t\t});\n\t\t\t\tdupMap.DT = dupMap.Close = 1;\n\t\t\t\tif (\n\t\t\t\t\tshowChange &&\n\t\t\t\t\tCIQ.ChartEngine.isDailyInterval(this.layout.interval)\n\t\t\t\t) {\n\t\t\t\t\tfields.push({\n\t\t\t\t\t\tmember: \"Change\",\n\t\t\t\t\t\tdisplay: \"Change\",\n\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (showOhl) {\n\t\t\t\t\tfields.push({\n\t\t\t\t\t\tmember: \"Open\",\n\t\t\t\t\t\tdisplay: \"Open\",\n\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t});\n\t\t\t\t\tfields.push({\n\t\t\t\t\t\tmember: \"High\",\n\t\t\t\t\t\tdisplay: \"High\",\n\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t});\n\t\t\t\t\tfields.push({\n\t\t\t\t\t\tmember: \"Low\",\n\t\t\t\t\t\tdisplay: \"Low\",\n\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t});\n\t\t\t\t\tdupMap.Open = dupMap.High = dupMap.Low = 1;\n\t\t\t\t}\n\t\t\t\tif (showVolume) {\n\t\t\t\t\tfields.push({\n\t\t\t\t\t\tmember: \"Volume\",\n\t\t\t\t\t\tdisplay: \"Volume\",\n\t\t\t\t\t\tpanel: null,\n\t\t\t\t\t\tyAxis: null\n\t\t\t\t\t}); // null yAxis use raw value\n\t\t\t\t\tdupMap.Volume = 1;\n\t\t\t\t}\n\t\t\t\tif (showSeries) {\n\t\t\t\t\tvar renderers = this.chart.seriesRenderers;\n\t\t\t\t\tfor (var renderer in renderers) {\n\t\t\t\t\t\tvar rendererToDisplay = renderers[renderer];\n\t\t\t\t\t\tif (rendererToDisplay === this.mainSeriesRenderer) continue;\n\t\t\t\t\t\tpanel = this.panels[rendererToDisplay.params.panel];\n\t\t\t\t\t\tyAxis = rendererToDisplay.params.yAxis;\n\t\t\t\t\t\tif (!yAxis && rendererToDisplay.params.shareYAxis)\n\t\t\t\t\t\t\tyAxis = panel.yAxis;\n\t\t\t\t\t\tfor (var id = 0; id < rendererToDisplay.seriesParams.length; id++) {\n\t\t\t\t\t\t\tvar seriesParams = rendererToDisplay.seriesParams[id];\n\t\t\t\t\t\t\t// if a series has a symbol and a field then it maybe a object chain\n\t\t\t\t\t\t\tvar sKey = seriesParams.symbol;\n\t\t\t\t\t\t\tvar subField = seriesParams.field;\n\t\t\t\t\t\t\tif (!sKey) sKey = subField;\n\t\t\t\t\t\t\telse if (subField && sKey != subField)\n\t\t\t\t\t\t\t\tsKey = CIQ.createObjectChainNames(sKey, subField)[0];\n\t\t\t\t\t\t\tvar display =\n\t\t\t\t\t\t\t\tseriesParams.display ||\n\t\t\t\t\t\t\t\tseriesParams.symbol ||\n\t\t\t\t\t\t\t\tseriesParams.field;\n\t\t\t\t\t\t\tif (sKey && !dupMap[display]) {\n\t\t\t\t\t\t\t\tfields.push({\n\t\t\t\t\t\t\t\t\tmember: sKey,\n\t\t\t\t\t\t\t\t\tdisplay: display,\n\t\t\t\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\t\t\t\tyAxis: yAxis,\n\t\t\t\t\t\t\t\t\tisSeries: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdupMap[display] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (showStudies) {\n\t\t\t\t\tfor (var study in this.layout.studies) {\n\t\t\t\t\t\tvar sd = this.layout.studies[study];\n\t\t\t\t\t\tpanel = this.panels[sd.panel];\n\t\t\t\t\t\tyAxis = panel && sd.getYAxis(this);\n\t\t\t\t\t\tfor (var output in this.layout.studies[study].outputMap) {\n\t\t\t\t\t\t\tif (output && !dupMap[output]) {\n\t\t\t\t\t\t\t\tfields.push({\n\t\t\t\t\t\t\t\t\tmember: output,\n\t\t\t\t\t\t\t\t\tdisplay: output,\n\t\t\t\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tdupMap[output] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!dupMap[study + \"_hist\"]) {\n\t\t\t\t\t\t\tfields.push({\n\t\t\t\t\t\t\t\tmember: study + \"_hist\",\n\t\t\t\t\t\t\t\tdisplay: study + \"_hist\",\n\t\t\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tfields.push({\n\t\t\t\t\t\t\t\tmember: study + \"_hist1\",\n\t\t\t\t\t\t\t\tdisplay: study + \"_hist1\",\n\t\t\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tfields.push({\n\t\t\t\t\t\t\t\tmember: study + \"_hist2\",\n\t\t\t\t\t\t\t\tdisplay: study + \"_hist2\",\n\t\t\t\t\t\t\t\tpanel: panel,\n\t\t\t\t\t\t\t\tyAxis: yAxis\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdupMap[study + \"_hist\"] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var f = 0; f < fields.length; f++) {\n\t\t\t\t\tvar obj = fields[f];\n\t\t\t\t\tvar name = obj.member;\n\t\t\t\t\tvar displayName = obj.display;\n\t\t\t\t\tvar isRecordDate = name == \"DT\";\n\t\t\t\t\tif (\n\t\t\t\t\t\tisRecordDate &&\n\t\t\t\t\t\t!useDataZone &&\n\t\t\t\t\t\t!CIQ.ChartEngine.isDailyInterval(stx.layout.interval)\n\t\t\t\t\t)\n\t\t\t\t\t\tname = \"displayDate\"; // display date is timezone adjusted\n\t\t\t\t\tpanel = obj.panel;\n\t\t\t\t\tyAxis = obj.yAxis;\n\t\t\t\t\tvar labelDecimalPlaces = null;\n\t\t\t\t\tif (yAxis) {\n\t\t\t\t\t\tif (!panel || panel !== panel.chart.panel) {\n\t\t\t\t\t\t\t// If a study panel, use yAxis settings to determine decimal places\n\t\t\t\t\t\t\tif (yAxis.decimalPlaces || yAxis.decimalPlaces === 0)\n\t\t\t\t\t\t\t\tlabelDecimalPlaces = yAxis.decimalPlaces;\n\t\t\t\t\t\t\telse if (yAxis.maxDecimalPlaces || yAxis.maxDecimalPlaces === 0)\n\t\t\t\t\t\t\t\tlabelDecimalPlaces = yAxis.maxDecimalPlaces;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If a chart panel, then always display at least the number of decimal places as calculated by masterData (panel.chart.decimalPlaces)\n\t\t\t\t\t\t\t// but if we are zoomed to high granularity then expand all the way out to the y-axis significant digits (panel.yAxis.printDecimalPlaces)\n\t\t\t\t\t\t\tlabelDecimalPlaces = Math.max(\n\t\t\t\t\t\t\t\tyAxis.printDecimalPlaces,\n\t\t\t\t\t\t\t\tpanel.chart.decimalPlaces\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t//\t... and never display more decimal places than the symbol is supposed to be quoting at\n\t\t\t\t\t\t\tif (yAxis.maxDecimalPlaces || yAxis.maxDecimalPlaces === 0)\n\t\t\t\t\t\t\t\tlabelDecimalPlaces = Math.min(\n\t\t\t\t\t\t\t\t\tlabelDecimalPlaces,\n\t\t\t\t\t\t\t\t\tyAxis.maxDecimalPlaces\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar dsField = null;\n\t\t\t\t\t// account for object chains\n\t\t\t\t\tvar tuple = CIQ.existsInObjectChain(data, name);\n\t\t\t\t\tif (tuple) dsField = tuple.obj[tuple.member];\n\t\t\t\t\telse if (name == \"Change\") dsField = data.Close - data.iqPrevClose;\n\n\t\t\t\t\tvar fieldName = displayName.replace(/^(Result )(.*)/, \"$2\");\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tshowInterpolation &&\n\t\t\t\t\t\tfields[f].isSeries &&\n\t\t\t\t\t\t(dsField === null || typeof dsField == \"undefined\")\n\t\t\t\t\t) {\n\t\t\t\t\t\t// do this only for additional series and not the main series\n\t\t\t\t\t\tvar seriesPrice = this.valueFromInterpolation(\n\t\t\t\t\t\t\tbar,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\t\"Close\",\n\t\t\t\t\t\t\tpanel,\n\t\t\t\t\t\t\tyAxis\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (seriesPrice === null) break;\n\t\t\t\t\t\tdsField = seriesPrice;\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\t(dsField || dsField === 0) &&\n\t\t\t\t\t\t(isRecordDate ||\n\t\t\t\t\t\t\ttypeof dsField !== \"object\" ||\n\t\t\t\t\t\t\tdsField.Close ||\n\t\t\t\t\t\t\tdsField.Close === 0)\n\t\t\t\t\t) {\n\t\t\t\t\t\tvar fieldValue = \"\";\n\t\t\t\t\t\tif (dsField.Close || dsField.Close === 0) dsField = dsField.Close;\n\t\t\t\t\t\tif (dsField.constructor == Number) {\n\t\t\t\t\t\t\tif (!yAxis) {\n\t\t\t\t\t\t\t\t// raw value\n\t\t\t\t\t\t\t\tfieldValue = dsField;\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tyAxis.originalPriceFormatter &&\n\t\t\t\t\t\t\t\tyAxis.originalPriceFormatter.func\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// in comparison mode with custom formatter\n\t\t\t\t\t\t\t\tfieldValue = yAxis.originalPriceFormatter.func(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\tpanel,\n\t\t\t\t\t\t\t\t\tdsField,\n\t\t\t\t\t\t\t\t\tlabelDecimalPlaces\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tyAxis.priceFormatter &&\n\t\t\t\t\t\t\t\tyAxis.priceFormatter != CIQ.Comparison.priceFormat\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// using custom formatter\n\t\t\t\t\t\t\t\tfieldValue = yAxis.priceFormatter(\n\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\tpanel,\n\t\t\t\t\t\t\t\t\tdsField,\n\t\t\t\t\t\t\t\t\tlabelDecimalPlaces\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfieldValue = this.formatYAxisPrice(\n\t\t\t\t\t\t\t\t\tdsField,\n\t\t\t\t\t\t\t\t\tpanel,\n\t\t\t\t\t\t\t\t\tlabelDecimalPlaces,\n\t\t\t\t\t\t\t\t\tyAxis\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (dsField.constructor == Date) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tisRecordDate &&\n\t\t\t\t\t\t\t\tthis.controls.floatDate &&\n\t\t\t\t\t\t\t\tthis.controls.floatDate.innerHTML\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (this.chart.xAxis.noDraw) fieldValue = \"N/A\";\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tfieldValue = CIQ.displayableDate(this, panel.chart, dsField);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfieldValue = CIQ.yyyymmdd(dsField);\n\t\t\t\t\t\t\t\tif (!CIQ.ChartEngine.isDailyInterval(this.layout.interval)) {\n\t\t\t\t\t\t\t\t\tfieldValue += \" \" + dsField.toTimeString().substr(0, 8);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfieldValue = dsField;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar dedicatedField = node.find(\n\t\t\t\t\t\t\t'stx-hu-tooltip-field[field=\"' + fieldName + '\"]'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (dedicatedField.length) {\n\t\t\t\t\t\t\tdedicatedField\n\t\t\t\t\t\t\t\t.find(\"stx-hu-tooltip-field-value\")\n\t\t\t\t\t\t\t\t.html(fieldValue);\n\t\t\t\t\t\t\tvar fieldNameField = dedicatedField.find(\n\t\t\t\t\t\t\t\t\"stx-hu-tooltip-field-name\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (fieldNameField.html() === \"\")\n\t\t\t\t\t\t\t\tfieldNameField.html(this.translateIf(fieldName));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$(\"<stx-hu-tooltip-field auto></stx-hu-tooltip-field>\")\n\t\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t\t$(\n\t\t\t\t\t\t\t\t\t\t\"<stx-hu-tooltip-field-name>\" +\n\t\t\t\t\t\t\t\t\t\t\tthis.translateIf(fieldName) +\n\t\t\t\t\t\t\t\t\t\t\t\"</stx-hu-tooltip-field-name>\"\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.append(\n\t\t\t\t\t\t\t\t\t$(\n\t\t\t\t\t\t\t\t\t\t\"<stx-hu-tooltip-field-value>\" +\n\t\t\t\t\t\t\t\t\t\t\tfieldValue +\n\t\t\t\t\t\t\t\t\t\t\t\"</stx-hu-tooltip-field-value>\"\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.appendTo(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar naField = node.find(\n\t\t\t\t\t\t\t'stx-hu-tooltip-field[field=\"' + fieldName + '\"]'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (naField.length) {\n\t\t\t\t\t\t\tvar naFieldNameField = naField.find(\"stx-hu-tooltip-field-name\");\n\t\t\t\t\t\t\tif (naFieldNameField.html() !== \"\")\n\t\t\t\t\t\t\t\tnaField.find(\"stx-hu-tooltip-field-value\").html(\"n/a\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.huTooltip.render();\n\t\t\t}\n\n\t\t\tCIQ.ChartEngine.prototype.append(\"undisplayCrosshairs\", function () {\n\t\t\t\tvar tt = this.huTooltip;\n\t\t\t\tif (tt && tt.node) {\n\t\t\t\t\tvar node = $(tt.node);\n\t\t\t\t\tif (node && node[0]) {\n\t\t\t\t\t\tnode[0].style.left = \"-50000px\";\n\t\t\t\t\t\tnode[0].style.right = \"auto\";\n\t\t\t\t\t\ttt.lastBar = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\tCIQ.ChartEngine.prototype.append(\"deleteHighlighted\", function () {\n\t\t\t\tthis.huTooltip.lastBar = {};\n\t\t\t\tthis.headsUpHR();\n\t\t\t});\n\t\t\tCIQ.ChartEngine.prototype.append(\"headsUpHR\", renderFunction);\n\t\t\tCIQ.ChartEngine.prototype.append(\"createDataSegment\", renderFunction);\n\t\t\tstx.huTooltip = new CIQ.Marker.Tooltip({\n\t\t\t\tstx: stx,\n\t\t\t\txPositioner: \"bar\",\n\t\t\t\tchartContainer: true,\n\t\t\t\tnode: node\n\t\t\t});\n\t\t};\n}\n\n};\n\n\nlet _exports = {CIQ: _js_chartiq_js__WEBPACK_IMPORTED_MODULE_0__[\"CIQ\"]};\n\n\n\n\n\n\n\n\n\n\n\n\n/* global __TREE_SHAKE__ */\nif (true) {\n\t(_exports.CIQ || _js_chartiq_js__WEBPACK_IMPORTED_MODULE_0__[\"CIQ\"]).activateImports(\n\t\t__js_addons_animation_,\n\t\t__js_addons_continuousZoom_,\n\t\t__js_addons_extendedHours_,\n\t\t__js_addons_fullScreen_,\n\t\t__js_addons_inactivityTimer_,\n\t\t__js_addons_outliers_,\n\t\t__js_addons_plotComplementer_,\n\t\t__js_addons_rangeSlider_,\n\t\t__js_addons_tooltip_,\n\t\tnull\n\t);\n}\n\n\n//# sourceURL=webpack:///./src/js/addOns.js?");

/***/ })

}]);